ASSESSMENT SUMMARY

Compilation:  PASSED
API:          PASSED

Spotbugs:     FAILED (14 warnings)
PMD:          FAILED (10 warnings)
Checkstyle:   FAILED (0 errors, 1 warning)

Correctness:  15/41 tests passed
Memory:       1/1 tests passed
Timing:       8/41 tests passed

Aggregate score: 45.85%
[Compilation: 5%, API: 5%, Spotbugs: 0%, PMD: 0%, Checkstyle: 0%, Correctness: 60%, Memory: 10%, Timing: 20%]

ASSESSMENT DETAILS

The following files were submitted:
----------------------------------
5.8K Jan  6 17:22 BruteCollinearPoints.java
8.7K Jan  6 17:22 FastCollinearPoints.java
4.3K Jan  6 17:22 Point.java


********************************************************************************
*  COMPILING
********************************************************************************


% javac11 Point.java
*-----------------------------------------------------------

% javac11 LineSegment.java
*-----------------------------------------------------------

% javac11 BruteCollinearPoints.java
*-----------------------------------------------------------

% javac11 FastCollinearPoints.java
*-----------------------------------------------------------


================================================================


Checking the APIs of your programs.
*-----------------------------------------------------------
Point:

BruteCollinearPoints:

FastCollinearPoints:

================================================================


********************************************************************************
*  CHECKING STYLE AND COMMON BUG PATTERNS
********************************************************************************


% spotbugs *.class
*-----------------------------------------------------------
M D UC_USELESS_OBJECT UC: The object stored in the variable 'pt' is created and modified, but its value never goes outside of the method 'main()' or produces any side effect.  At Point.java:[line 133]
M D UC_USELESS_OBJECT UC: The object stored in the variable 'pt2' is created and modified, but its value never goes outside of the method 'main()' or produces any side effect.  At Point.java:[line 134]
M D DLS_DEAD_LOCAL_STORE DLS: Assigns a value to the local variable 'slopeResult' but that value is never used.  At Point.java:[line 136]
M D DLS_DEAD_LOCAL_STORE DLS: Assigns a value to the local variable 'comparator' but that value is never used.  At Point.java:[line 137]
M D DLS_DEAD_LOCAL_STORE DLS: Assigns a value to the local variable 'compareResult' but that value is never used.  At Point.java:[line 135]
L D FE_FLOATING_POINT_EQUALITY FE: Tests for exact floating-point equality. Because floating-point calculations may involve rounding, the calculated values may be imprecise.  At Point.java:[line 68]
H D UC_USELESS_VOID_METHOD UC: The void method 'main()' appears to serve no purpose.  At Point.java:[line 139]
M V EI_EXPOSE_REP2 EI2: Stores a reference to an externally mutable object in the instance variable 'points', exposing the internal representation of the class 'BruteCollinearPoints'. Instead, create a defensive copy of the object referenced by the parameter variable 'points' and store that copy in the instance variable 'points'.  At BruteCollinearPoints.java:[line 23]
L D FE_FLOATING_POINT_EQUALITY FE: Tests for exact floating-point equality. Because floating-point calculations may involve rounding, the calculated values may be imprecise.  At BruteCollinearPoints.java:[line 57]
M V EI_EXPOSE_REP2 EI2: Stores a reference to an externally mutable object in the instance variable 'points', exposing the internal representation of the class 'FastCollinearPoints'. Instead, create a defensive copy of the object referenced by the parameter variable 'points' and store that copy in the instance variable 'points'.  At FastCollinearPoints.java:[line 23]
L D FE_FLOATING_POINT_EQUALITY FE: Tests for exact floating-point equality. Because floating-point calculations may involve rounding, the calculated values may be imprecise.  At FastCollinearPoints.java:[line 86]
L P SIC_INNER_SHOULD_BE_STATIC_ANON SIC: Should the anonymous inner class 'BruteCollinearPoints$1' be refactored into a named static nested class?  At BruteCollinearPoints.java:[line 97]
L P SIC_INNER_SHOULD_BE_STATIC_ANON SIC: Should the anonymous inner class 'FastCollinearPoints$1' be refactored into a named static nested class?  At FastCollinearPoints.java:[line 170]
L P SIC_INNER_SHOULD_BE_STATIC_ANON SIC: Should the anonymous inner class 'FastCollinearPoints$2' be refactored into a named static nested class?  At FastCollinearPoints.java:[line 178]
Warnings generated: 14


================================================================


% pmd .
*-----------------------------------------------------------
BruteCollinearPoints.java:17: The private instance (or static) variable 'points' can be made 'final'; it is initialized only in the declaration or constructor. [ImmutableField]
BruteCollinearPoints.java:19: The user-supplied array 'points' is stored directly. [ArrayIsStoredDirectly]
FastCollinearPoints.java:17: The private instance (or static) variable 'points' can be made 'final'; it is initialized only in the declaration or constructor. [ImmutableField]
FastCollinearPoints.java:19: The user-supplied array 'points' is stored directly. [ArrayIsStoredDirectly]
FastCollinearPoints.java:42: The private instance (or static) variable 'origin' can be made 'final'; it is initialized only in the declaration or constructor. [ImmutableField]
FastCollinearPoints.java:43: The private instance (or static) variable 'point' can be made 'final'; it is initialized only in the declaration or constructor. [ImmutableField]
FastCollinearPoints.java:44: The private instance (or static) variable 'slopeToOrigin' can be made 'final'; it is initialized only in the declaration or constructor. [ImmutableField]
Point.java:135: Avoid unused local variables, such as 'compareResult'. [UnusedLocalVariable]
Point.java:136: Avoid unused local variables, such as 'slopeResult'. [UnusedLocalVariable]
Point.java:137: Avoid unused local variables, such as 'comparator'. [UnusedLocalVariable]
PMD ends with 10 warnings.


================================================================


% checkstyle *.java
*-----------------------------------------------------------

% custom checkstyle checks for Point.java
*-----------------------------------------------------------

% custom checkstyle checks for BruteCollinearPoints.java
*-----------------------------------------------------------

% custom checkstyle checks for FastCollinearPoints.java
*-----------------------------------------------------------
[WARN] FastCollinearPoints.java:15:1: Defining a nested class in this program suggests poor design. [Design]
Checkstyle ends with 0 errors and 1 warning.


================================================================


********************************************************************************
*  TESTING CORRECTNESS
********************************************************************************

Testing correctness of Point
*-----------------------------------------------------------
Running 3 total tests.

Test 1: p.slopeTo(q)
  * positive infinite slope, where p and q have coordinates in [0, 500)
  * positive infinite slope, where p and q have coordinates in [0, 32768)
  * negative infinite slope, where p and q have coordinates in [0, 500)
  * negative infinite slope, where p and q have coordinates in [0, 32768)
  * positive zero     slope, where p and q have coordinates in [0, 500)
  * positive zero     slope, where p and q have coordinates in [0, 32768)
  * symmetric for random points p and q with coordinates in [0, 500)
  * symmetric for random points p and q with coordinates in [0, 32768)
  * transitive for random points p, q, and r with coordinates in [0, 500)
  * transitive for random points p, q, and r with coordinates in [0, 32768)
  * slopeTo(), where p and q have coordinates in [0, 500)
  * slopeTo(), where p and q have coordinates in [0, 32768)
  * slopeTo(), where p and q have coordinates in [0, 10)
  * throw a java.lang.NullPointerException if argument is null
==> passed

Test 2: p.compareTo(q)
  * reflexive, where p and q have coordinates in [0, 500)
  * reflexive, where p and q have coordinates in [0, 32768)
  * antisymmetric, where p and q have coordinates in [0, 500)
  * antisymmetric, where p and q have coordinates in [0, 32768)
  * transitive, where p, q, and r have coordinates in [0, 500)
  * transitive, where p, q, and r have coordinates in [0, 32768)
  * sign of compareTo(), where p and q have coordinates in [0, 500)
  * sign of compareTo(), where p and q have coordinates in [0, 32768)
  * sign of compareTo(), where p and q have coordinates in [0, 10)
  * throw java.lang.NullPointerException exception if argument is null
==> passed

Test 3: p.slopeOrder().compare(q, r)
  * reflexive, where p and q have coordinates in [0, 500)
  * reflexive, where p and q have coordinates in [0, 32768)
  * antisymmetric, where p, q, and r have coordinates in [0, 500)
  * antisymmetric, where p, q, and r have coordinates in [0, 32768)
  * transitive, where p, q, r, and s have coordinates in [0, 500)
  * transitive, where p, q, r, and s have coordinates in [0, 32768)
  * sign of compare(), where p, q, and r have coordinates in [0, 500)
  * sign of compare(), where p, q, and r have coordinates in [0, 32768)
  * sign of compare(), where p, q, and r have coordinates in [0, 10)
  * throw java.lang.NullPointerException if either argument is null
==> passed


Total: 3/3 tests passed!


================================================================
********************************************************************************
*  TESTING CORRECTNESS (substituting reference Point and LineSegment)
********************************************************************************

Testing correctness of BruteCollinearPoints
*-----------------------------------------------------------
Running 17 total tests.

The inputs satisfy the following conditions:
  - no duplicate points
  - no 5 (or more) points are collinear
  - all x- and y-coordinates between 0 and 32,767

Test 1: points from a file
  * filename = input8.txt
    - number of entries in student   solution: 0
    - number of entries in reference solution: 2
    - 2 missing entries in student solution, including:
      '(3000, 4000) -> (6000, 7000) -> (14000, 15000) -> (20000, 21000)'


  * filename = equidistant.txt
    - number of entries in student   solution: 0
    - number of entries in reference solution: 4
    - 4 missing entries in student solution, including:
      '(30000, 0) -> (20000, 10000) -> (10000, 20000) -> (0, 30000)'


  * filename = input40.txt
    - number of entries in student   solution: 0
    - number of entries in reference solution: 4
    - 4 missing entries in student solution, including:
      '(2000, 29000) -> (4000, 29000) -> (22000, 29000) -> (28000, 29000)'


  * filename = input48.txt
    - number of entries in student   solution: 0
    - number of entries in reference solution: 6
    - 6 missing entries in student solution, including:
      '(1000, 26000) -> (9000, 26000) -> (11000, 26000) -> (18000, 26000)'


==> FAILED

Test 2a: points from a file with horizontal line segments
  * filename = horizontal5.txt
    - number of entries in student   solution: 0
    - number of entries in reference solution: 5
    - 5 missing entries in student solution, including:
      '(2682, 14118) -> (5067, 14118) -> (7453, 14118) -> (7821, 14118)'


  * filename = horizontal25.txt
    - number of entries in student   solution: 0
    - number of entries in reference solution: 25
    - 25 missing entries in student solution, including:
      '(8784, 20913) -> (9880, 20913) -> (16352, 20913) -> (19666, 20913)'


==> FAILED

Test 2b: random horizontal line segments
  *  1 random horizontal line segment
  *  5 random horizontal line segments
    - number of entries in student   solution: 0
    - number of entries in reference solution: 5
    - 5 missing entries in student solution, including:
      '(5537, 15032) -> (7602, 15032) -> (19005, 15032) -> (20444, 15032)'


    - failed on trial 1 of 250
     20
     18268 12800
      3700  1069
      5572  9397
     20444 15032
      7331  9397
     13924 12800
     11671  1069
     12465  4899
     18751  4899
     12463  4899
     18570  9397
      5537 15032
     18829 12800
     19005 15032
      7602 15032
      4378  1069
     11071  4899
      6448 12800
     17924  9397
     16353  1069

  * 10 random horizontal line segments
    - number of entries in student   solution: 0
    - number of entries in reference solution: 10
    - 10 missing entries in student solution, including:
      '(5836, 17307) -> (8519, 17307) -> (15443, 17307) -> (16131, 17307)'


    - failed on trial 1 of 50

  * 15 random horizontal line segments
    - number of entries in student   solution: 0
    - number of entries in reference solution: 15
    - 15 missing entries in student solution, including:
      '(17108, 20945) -> (17648, 20945) -> (20697, 20945) -> (20845, 20945)'


    - failed on trial 1 of 5

==> FAILED

Test 3a: points from a file with vertical line segments
  * filename = vertical5.txt
    - number of entries in student   solution: 0
    - number of entries in reference solution: 5
    - 5 missing entries in student solution, including:
      '(14407, 10367) -> (14407, 17188) -> (14407, 17831) -> (14407, 19953)'


  * filename = vertical25.txt
    - number of entries in student   solution: 0
    - number of entries in reference solution: 25
    - 25 missing entries in student solution, including:
      '(19953, 10489) -> (19953, 10688) -> (19953, 19299) -> (19953, 20439)'


==> FAILED

Test 3b: random vertical line segments
  *  1 random vertical line segment
  *  5 random vertical line segments
    - number of entries in student   solution: 0
    - number of entries in reference solution: 5
    - 5 missing entries in student solution, including:
      '(3924, 4363) -> (3924, 14317) -> (3924, 15637) -> (3924, 16998)'


    - failed on trial 1 of 250
     20
      3924 15637
     16113  7490
      3924 14317
     16113 15564
     16113 16189
     13325  7050
      7672  3556
      7672  5576
     13325  3041
      7672 17584
     13325 19359
     16113  4332
      3623  3810
      3924 16998
      7672 19006
      3924  4363
     13325  5474
      3623  4817
      3623  4688
      3623 16638

  * 10 random vertical line segments
    - number of entries in student   solution: 0
    - number of entries in reference solution: 10
    - 10 missing entries in student solution, including:
      '(13321, 12072) -> (13321, 14743) -> (13321, 16361) -> (13321, 19816)'


    - failed on trial 1 of 50

  * 15 random vertical line segments
    - number of entries in student   solution: 0
    - number of entries in reference solution: 15
    - 15 missing entries in student solution, including:
      '(20441, 13592) -> (20441, 19897) -> (20441, 19900) -> (20441, 20498)'


    - failed on trial 1 of 5

==> FAILED

Test 4a: points from a file with no line segments
  * filename = random23.txt
  * filename = random38.txt
==> passed

Test 4b: random points with no line segments
  *  5 random points
  * 10 random points
  * 20 random points
  * 50 random points
==> passed

Test 5: points from a file with fewer than 4 points
  * filename = input1.txt
  * filename = input2.txt
  * filename = input3.txt
==> passed

Test 6: check for dependence on either compareTo() or compare()
        returning { -1, +1, 0 } instead of { negative integer,
        positive integer, zero }
  * filename = equidistant.txt
    - number of entries in student   solution: 0
    - number of entries in reference solution: 4
    - 4 missing entries in student solution, including:
      '(30000, 0) -> (20000, 10000) -> (10000, 20000) -> (0, 30000)'


  * filename = input40.txt
    - number of entries in student   solution: 0
    - number of entries in reference solution: 4
    - 4 missing entries in student solution, including:
      '(2000, 29000) -> (4000, 29000) -> (22000, 29000) -> (28000, 29000)'


  * filename = input48.txt
    - number of entries in student   solution: 0
    - number of entries in reference solution: 6
    - 6 missing entries in student solution, including:
      '(1000, 26000) -> (9000, 26000) -> (11000, 26000) -> (18000, 26000)'


==> FAILED

Test 7: check for fragile dependence on return value of toString()
  * filename = equidistant.txt
    - number of entries in student   solution: 0
    - number of entries in reference solution: 4
    - 4 missing entries in student solution, including:
      '(30000, 0) -> (20000, 10000) -> (10000, 20000) -> (0, 30000)'


  * filename = input40.txt
    - number of entries in student   solution: 0
    - number of entries in reference solution: 4
    - 4 missing entries in student solution, including:
      '(2000, 29000) -> (4000, 29000) -> (22000, 29000) -> (28000, 29000)'


  * filename = input48.txt
    - number of entries in student   solution: 0
    - number of entries in reference solution: 6
    - 6 missing entries in student solution, including:
      '(1000, 26000) -> (9000, 26000) -> (11000, 26000) -> (18000, 26000)'



It is bad style to write code that depends on the particular format of
the output from the toString() method, especially if your reason for
doing so is to circumvent the public API (which intentionally does not
provide access to the x- and y-coordinates).

==> FAILED

Test 8: random line segments, none vertical or horizontal
  *  1 random line segment
  *  5 random line segments
    - number of entries in student   solution: 0
    - number of entries in reference solution: 5
    - 5 missing entries in student solution, including:
      '(1669, 6216) -> (10379, 6466) -> (12121, 6516) -> (12992, 6541)'


    - failed on trial 1 of 250
     20
     10379  6466
     10075 13517
      1669  6216
      5833  6114
     12121  6516
      4286   199
     10937  1733
     14387  6318
      5952  6569
     13697  5401
      8309  6565
      2845  5685
      8992  6675
      9867  6669
     10247   816
     12407  7225
      9958  9665
      5357  4294
      9672   249
     12992  6541

  * 10 random line segments
    - number of entries in student   solution: 0
    - number of entries in reference solution: 10
    - 10 missing entries in student solution, including:
      '(5280, 10000) -> (6784, 10770) -> (11296, 13080) -> (14304, 14620)'


    - failed on trial 1 of 100

  * 15 random line segments
    - number of entries in student   solution: 0
    - number of entries in reference solution: 15
    - 15 missing entries in student solution, including:
      '(6160, 10818) -> (7534, 11574) -> (13946, 15102) -> (17610, 17118)'


    - failed on trial 1 of 50

==> FAILED

Test 9: random line segments
  *  1 random line segment
  *  5 random line segments
    - number of entries in student   solution: 0
    - number of entries in reference solution: 5
    - 5 missing entries in student solution, including:
      '(6235, 10589) -> (7285, 10589) -> (7635, 10589) -> (7985, 10589)'


    - failed on trial 1 of 250
     20
     10770  5641
      4761 10935
      6607 13712
      6728  8889
      4965 11193
       477  5517
      6607 14052
     10305  5176
      6607  8357
      1157  6377
      6607 12862
     13157  8028
     11886  6757
      2894  4515
      6444  8565
      5308  7269
      7285 10589
      6235 10589
      7635 10589
      7985 10589

  * 10 random line segments
    - number of entries in student   solution: 0
    - number of entries in reference solution: 10
    - 10 missing entries in student solution, including:
      '(7564, 12600) -> (9629, 13930) -> (10160, 14272) -> (10632, 14576)'


    - failed on trial 1 of 100

  * 15 random line segments
    - number of entries in student   solution: 0
    - number of entries in reference solution: 15
    - 15 missing entries in student solution, including:
      '(7444, 11951) -> (7699, 12096) -> (7801, 12154) -> (8158, 12357)'


    - failed on trial 1 of 50

==> FAILED

Test 10: check that data type is immutable by testing whether each method
         returns the same value, regardless of any intervening operations
  * input8.txt

    java.lang.NullPointerException

    BruteCollinearPoints.segments(BruteCollinearPoints.java:54)
    TestBruteCollinearPoints.testImmutable(TestBruteCollinearPoints.java:458)
    TestBruteCollinearPoints.testImmutable(TestBruteCollinearPoints.java:516)
    TestBruteCollinearPoints.test10(TestBruteCollinearPoints.java:531)
    TestBruteCollinearPoints.main(TestBruteCollinearPoints.java:753)

    - sequence of operations was:
          BruteCollinearPoints collinear = new BruteCollinearPoints(points);
          collinear.segments()
          collinear.numberOfSegments() -> 0
          collinear.numberOfSegments() -> 0
          mutate array returned by last call to segments()
          mutate array returned by last call to segments()
          collinear.segments()
          collinear.segments()
          collinear.numberOfSegments() -> 0
          mutate array returned by last call to segments()
          collinear.numberOfSegments() -> 0
          mutate points[] array that was passed to constructor
          collinear.segments()

    - failed on trial 1 of 100

  * equidistant.txt

    java.lang.NullPointerException

    BruteCollinearPoints.segments(BruteCollinearPoints.java:54)
    BruteCollinearPoints.numberOfSegments(BruteCollinearPoints.java:38)
    TestBruteCollinearPoints.testImmutable(TestBruteCollinearPoints.java:438)
    TestBruteCollinearPoints.testImmutable(TestBruteCollinearPoints.java:516)
    TestBruteCollinearPoints.test10(TestBruteCollinearPoints.java:532)
    TestBruteCollinearPoints.main(TestBruteCollinearPoints.java:753)

    - sequence of operations was:
          BruteCollinearPoints collinear = new BruteCollinearPoints(points);
          collinear.segments()
          mutate points[] array that was passed to constructor
          mutate array returned by last call to segments()
          collinear.numberOfSegments()

    - failed on trial 1 of 100

==> FAILED

Test 11: check that data type does not mutate the constructor argument
  * input8.txt
  * equidistant.txt
==> passed

Test 12: numberOfSegments() is consistent with segments()
  * filename = input8.txt
  * filename = equidistant.txt
  * filename = input40.txt
  * filename = input48.txt
  * filename = horizontal5.txt
  * filename = vertical5.txt
  * filename = random23.txt
==> passed

Test 13: throws an exception if either the constructor argument is null
         or any entry in array is null
  * argument is null
  * Point[] of length 10, number of null entries = 1
    - constructor throws wrong exception
    - constructor throws a java.lang.NullPointerException
    - constructor should throw a java.lang.IllegalArgumentException
     10
      8786  9585
      6846 31003
     12021 27079
     23050  7703
     22658 11361
     23002 22857
     null
     11452  1943
     31687 12185
      6296 16994

  * Point[] of length 10, number of null entries = 10
  * Point[] of length 4, number of null entries = 1
  * Point[] of length 3, number of null entries = 1
  * Point[] of length 2, number of null entries = 1
    - constructor throws wrong exception
    - constructor throws a java.lang.NullPointerException
    - constructor should throw a java.lang.IllegalArgumentException
     2
     25629  3034
     null

  * Point[] of length 1, number of null entries = 1
    - constructor fails to throw an exception
     1
     null

==> FAILED

Test 14: check that the constructor throws an exception if duplicate points
  * 50 points
  * 25 points
  * 5 points
  * 4 points
  * 3 points
  * 2 points
==> passed


Total: 6/17 tests passed!


================================================================
Testing correctness of FastCollinearPoints
*-----------------------------------------------------------
Running 21 total tests.

The inputs satisfy the following conditions:
  - no duplicate points
  - all x- and y-coordinates between 0 and 32,767

Test 1: points from a file
  * filename = input8.txt
  * filename = equidistant.txt
    - segments() contains the same segment more than once
    - segment 1: (10000, 0) -> (0, 30000)
    - segment 3: (10000, 0) -> (0, 30000)

    - number of entries in student   solution: 4
    - number of entries in reference solution: 4
    - 4 extra entries in student solution, including:
      '(18000, 2000) -> (2000, 18000)'

    - 4 missing entries in student solution, including:
      '(30000, 0) -> (20000, 10000) -> (10000, 20000) -> (0, 30000)'


  * filename = input40.txt
    - segments() contains the same segment more than once
    - segment 13: (26000, 8000) -> (1000, 31000)
    - segment 15: (26000, 8000) -> (1000, 31000)

    - number of entries in student   solution: 42
    - number of entries in reference solution: 4
    - 42 extra entries in student solution, including:
      '(22000, 29000) -> (10000, 31000)'

    - 4 missing entries in student solution, including:
      '(2000, 29000) -> (4000, 29000) -> (22000, 29000) -> (28000, 29000)'


  * filename = input48.txt
    - segments() contains the same segment more than once
    - segment 10: (18000, 13000) -> (23000, 29000)
    - segment 20: (18000, 13000) -> (23000, 29000)

    - number of entries in student   solution: 69
    - number of entries in reference solution: 6
    - 69 extra entries in student solution, including:
      '(5000, 29000) -> (17000, 31000)'

    - 6 missing entries in student solution, including:
      '(1000, 26000) -> (9000, 26000) -> (11000, 26000) -> (18000, 26000)'


  * filename = input299.txt
    - segments() contains the same segment more than once
    - segment 58: (29050, 5250) -> (16900, 32700)
    - segment 200: (29050, 5250) -> (16900, 32700)

    - number of entries in student   solution: 534
    - number of entries in reference solution: 6
    - 534 extra entries in student solution, including:
      '(600, 31900) -> (1000, 32650)'

    - 6 missing entries in student solution, including:
      '(3250, 17450) -> (8500, 17450) -> (13400, 17450) -> (17250, 17450)'


==> FAILED

Test 2a: points from a file with horizontal line segments
  * filename = horizontal5.txt
    - number of entries in student   solution: 1
    - number of entries in reference solution: 5
    - 1 extra entry in student solution:
      '(5766, 4652) -> (7821, 14118)'

    - 5 missing entries in student solution, including:
      '(2682, 14118) -> (5067, 14118) -> (7453, 14118) -> (7821, 14118)'


  * filename = horizontal25.txt
    - number of entries in student   solution: 1
    - number of entries in reference solution: 25
    - 1 extra entry in student solution:
      '(10021, 1256) -> (19666, 20913)'

    - 25 missing entries in student solution, including:
      '(8784, 20913) -> (9880, 20913) -> (16352, 20913) -> (19666, 20913)'


  * filename = horizontal50.txt
    - number of entries in student   solution: 1
    - number of entries in reference solution: 50
    - 1 extra entry in student solution:
      '(2624, 1040) -> (17428, 20754)'

    - 50 missing entries in student solution, including:
      '(5249, 20754) -> (5559, 20754) -> (14800, 20754) -> (17428, 20754)'


  * filename = horizontal75.txt
    - number of entries in student   solution: 2
    - number of entries in reference solution: 75
    - 2 extra entries in student solution, including:
      '(14707, 6016) -> (13795, 12628)'

    - 75 missing entries in student solution, including:
      '(1536, 20976) -> (6545, 20976) -> (14178, 20976) -> (14591, 20976)'


  * filename = horizontal100.txt
    - number of entries in student   solution: 2
    - number of entries in reference solution: 100
    - 2 extra entries in student solution, including:
      '(1672, 13404) -> (2656, 14586)'

    - 100 missing entries in student solution, including:
      '(5835, 20698) -> (7673, 20698) -> (16154, 20698) -> (19642, 20698)'


==> FAILED

Test 2b: random horizontal line segments
  *  1 random horizontal line segment
    - segments() contains a subsegment of a segment in reference solution
    - student   segment 0: (4093, 11112) -> (9192, 11112)
    - reference segment 0: (4093, 11112) -> (9192, 11112) -> (11246, 11112) -> (12435, 11112)

    - number of entries in student   solution: 1
    - number of entries in reference solution: 1
    - 1 extra entry in student solution:
      '(4093, 11112) -> (9192, 11112)'

    - 1 missing entry in student solution:
      '(4093, 11112) -> (9192, 11112) -> (11246, 11112) -> (12435, 11112)'


    - failed on trial 1 of 500
     4
      4093 11112
     11246 11112
      9192 11112
     12435 11112

  *  5 random horizontal line segments
    - number of entries in student   solution: 1
    - number of entries in reference solution: 5
    - 1 extra entry in student solution:
      '(7337, 10355) -> (15105, 20665)'

    - 5 missing entries in student solution, including:
      '(1293, 20665) -> (3460, 20665) -> (14633, 20665) -> (15105, 20665)'


    - failed on trial 1 of 250
     20
     19655 18291
     20584 16931
      3460 20665
     20013 15901
     20313 18291
     13443 10355
     18333 16931
      7337 10355
      6319 15901
     11683 16931
     20899 10355
     11333 18291
     14633 20665
     15105 20665
     12883 15901
      1293 20665
     18739 10355
     20406 15901
     17380 16931
     15854 18291

  * 10 random horizontal line segments
    - number of entries in student   solution: 1
    - number of entries in reference solution: 10
    - 1 extra entry in student solution:
      '(5533, 3977) -> (11866, 14046)'

    - 10 missing entries in student solution, including:
      '(2648, 14046) -> (7086, 14046) -> (11181, 14046) -> (11866, 14046)'


    - failed on trial 1 of 50

  * 15 random horizontal line segments
    - number of entries in student   solution: 1
    - number of entries in reference solution: 15
    - 1 extra entry in student solution:
      '(4899, 1333) -> (19487, 20761)'

    - 15 missing entries in student solution, including:
      '(10411, 20761) -> (13478, 20761) -> (16824, 20761) -> (19487, 20761)'


    - failed on trial 1 of 5

==> FAILED

Test 3a: points from a file with vertical line segments
  * filename = vertical5.txt
    - number of entries in student   solution: 1
    - number of entries in reference solution: 5
    - 1 extra entry in student solution:
      '(8421, 1829) -> (5757, 20856)'

    - 5 missing entries in student solution, including:
      '(14407, 10367) -> (14407, 17188) -> (14407, 17831) -> (14407, 19953)'


  * filename = vertical25.txt
    - number of entries in student   solution: 1
    - number of entries in reference solution: 25
    - 1 extra entry in student solution:
      '(9557, 1388) -> (13536, 20946)'

    - 25 missing entries in student solution, including:
      '(19953, 10489) -> (19953, 10688) -> (19953, 19299) -> (19953, 20439)'


  * filename = vertical50.txt
    - number of entries in student   solution: 1
    - number of entries in reference solution: 50
    - 1 extra entry in student solution:
      '(10209, 1143) -> (10695, 20927)'

    - 50 missing entries in student solution, including:
      '(5991, 15606) -> (5991, 20227) -> (5991, 20340) -> (5991, 20424)'


  * filename = vertical75.txt
    - number of entries in student   solution: 1
    - number of entries in reference solution: 75
    - 1 extra entry in student solution:
      '(9632, 1012) -> (18293, 20983)'

    - 75 missing entries in student solution, including:
      '(13780, 16365) -> (13780, 17494) -> (13780, 18253) -> (13780, 18908)'


  * filename = vertical100.txt
    - number of entries in student   solution: 2
    - number of entries in reference solution: 100
    - 2 extra entries in student solution, including:
      '(2977, 15792) -> (18009, 18793)'

    - 100 missing entries in student solution, including:
      '(15135, 15588) -> (15135, 17398) -> (15135, 19476) -> (15135, 20439)'


==> FAILED

Test 3b: random vertical line segments
  *  1 random vertical line segment
    - segments() contains a subsegment of a segment in reference solution
    - student   segment 0: (19903, 2913) -> (19903, 6574)
    - reference segment 0: (19903, 2913) -> (19903, 6574) -> (19903, 15185) -> (19903, 18298)

    - number of entries in student   solution: 1
    - number of entries in reference solution: 1
    - 1 extra entry in student solution:
      '(19903, 2913) -> (19903, 6574)'

    - 1 missing entry in student solution:
      '(19903, 2913) -> (19903, 6574) -> (19903, 15185) -> (19903, 18298)'


    - failed on trial 1 of 500
     4
     19903  2913
     19903  6574
     19903 18298
     19903 15185

  *  5 random vertical line segments
    - number of entries in student   solution: 1
    - number of entries in reference solution: 5
    - 4 missing entries in student solution, including:
      '(13805, 8895) -> (13805, 10403) -> (13805, 12026) -> (13805, 19771)'


    - failed on trial 1 of 250
     20
      9574 20404
      3906 15497
      3906 17452
     12757  8645
     14595 11617
     14595 19742
     13805 10403
     13805  8895
     14595  7230
      9574 19016
     12757  5407
     12757  5764
     14595  7712
      9574  2634
     12757  5373
      3906 18960
     13805 19771
      9574 19036
      3906  6368
     13805 12026

  * 10 random vertical line segments
    - number of entries in student   solution: 1
    - number of entries in reference solution: 10
    - 1 extra entry in student solution:
      '(13865, 1581) -> (16265, 20814)'

    - 10 missing entries in student solution, including:
      '(11750, 9387) -> (11750, 14496) -> (11750, 16164) -> (11750, 17810)'


    - failed on trial 1 of 50

  * 15 random vertical line segments
    - number of entries in student   solution: 1
    - number of entries in reference solution: 15
    - 1 extra entry in student solution:
      '(12670, 1472) -> (16900, 20900)'

    - 15 missing entries in student solution, including:
      '(14676, 8861) -> (14676, 11532) -> (14676, 15020) -> (14676, 20806)'


    - failed on trial 1 of 5

==> FAILED

Test 4a: points from a file with no line segments
  * filename = random23.txt
  * filename = random38.txt
  * filename = random91.txt
  * filename = random152.txt
==> passed

Test 4b: random points with no line segments
  *  5 random points
  * 10 random points
  * 20 random points
  * 50 random points
==> passed

Test 5a: points from a file with 5 or more on some line segments
  * filename = input9.txt
  * filename = input10.txt
    - segments() contains a subsegment of a segment in reference solution
    - student   segment 0: (23000, 16000) -> (3000, 26000)
    - reference segment 0: (28000, 13500) -> (23000, 16000) -> (13000, 21000) -> (3000, 26000)

    - number of entries in student   solution: 2
    - number of entries in reference solution: 2
    - 1 extra entry in student solution:
      '(23000, 16000) -> (3000, 26000)'

    - 1 missing entry in student solution:
      '(28000, 13500) -> (23000, 16000) -> (13000, 21000) -> (3000, 26000)'


  * filename = input20.txt
    - segments() contains the same segment more than once
    - segment 0: (7168, 25088) -> (7168, 29184)
    - segment 1: (7168, 25088) -> (7168, 29184)

    - number of entries in student   solution: 13
    - number of entries in reference solution: 5
    - 13 extra entries in student solution, including:
      '(8192, 26112) -> (7168, 29184)'

    - 5 missing entries in student solution, including:
      '(4160, 29184) -> (5120, 29184) -> (6144, 29184) -> (7168, 29184) -> (8192, 29184)'


  * filename = input50.txt
    - segments() contains the same segment more than once
    - segment 12: (25000, 1000) -> (9000, 29000)
    - segment 22: (25000, 1000) -> (9000, 29000)

    - number of entries in student   solution: 75
    - number of entries in reference solution: 7
    - 74 extra entries in student solution, including:
      '(5000, 29000) -> (17000, 31000)'

    - 6 missing entries in student solution, including:
      '(1000, 26000) -> (9000, 26000) -> (11000, 26000) -> (18000, 26000)'


  * filename = input80.txt
    - segments() contains the same segment more than once
    - segment 32: (15000, 0) -> (27000, 31000)
    - segment 38: (15000, 0) -> (27000, 31000)

    - segments() contains a subsegment of a segment in reference solution
    - student   segment 63: (25000, 8000) -> (25000, 27000)
    - reference segment 28: (25000, 8000) -> (25000, 9000) -> (25000, 12000) -> (25000, 27000) -> (25000, 29000) -> (25000, 31000)

    - number of entries in student   solution: 250
    - number of entries in reference solution: 31
    - 248 extra entries in student solution, including:
      '(15000, 30000) -> (29000, 31000)'

    - 29 missing entries in student solution, including:
      '(13000, 29000) -> (19000, 29000) -> (25000, 29000) -> (28000, 29000)'


  * filename = input300.txt
    - segments() contains the same segment more than once
    - segment 60: (29050, 5250) -> (16900, 32700)
    - segment 203: (29050, 5250) -> (16900, 32700)

    - number of entries in student   solution: 539
    - number of entries in reference solution: 6
    - 539 extra entries in student solution, including:
      '(600, 31900) -> (1000, 32650)'

    - 6 missing entries in student solution, including:
      '(3250, 17450) -> (8500, 17450) -> (13400, 17450) -> (17250, 17450)'


  * filename = inarow.txt
    - number of entries in student   solution: 6
    - number of entries in reference solution: 5
    - 3 extra entries in student solution, including:
      '(20000, 0) -> (0, 30000)'

    - 2 missing entries in student solution, including:
      '(30000, 0) -> (27000, 7500) -> (26000, 10000) -> (20000, 25000) -> (19000, 27500) -> (18000, 30000)'


==> FAILED

Test 5b: points from a file with 5 or more on some line segments
  * filename = kw1260.txt
    - segments() contains the same segment more than once
    - segment 2: (14820, 5966) -> (14557, 18640)
    - segment 4: (14820, 5966) -> (14557, 18640)

    - number of entries in student   solution: 1446
    - number of entries in reference solution: 288
    - 1355 extra entries in student solution, including:
      '(15574, 30361) -> (14236, 30449)'

    - 197 missing entries in student solution, including:
      '(16384, 30255) -> (15979, 30308) -> (15574, 30361) -> (15169, 30414) -> (14764, 30467)'


  * filename = rs1423.txt
    - segments() contains the same segment more than once
    - segment 52: (12936, 14466) -> (13685, 27948)
    - segment 1413: (12936, 14466) -> (13685, 27948)

    - segments() contains a subsegment of a segment in reference solution
    - student   segment 2: (31442, 1260) -> (31440, 1860)
    - reference segment 1: (31443, 960) -> (31442, 1260) -> (31441, 1560) -> (31440, 1860)

    - number of entries in student   solution: 1446
    - number of entries in reference solution: 443
    - 1285 extra entries in student solution, including:
      '(13927, 27810) -> (13443, 28086)'

    - 282 missing entries in student solution, including:
      '(14169, 27672) -> (13927, 27810) -> (13685, 27948) -> (13443, 28086)'


==> FAILED

Test 6: points from a file with fewer than 4 points
  * filename = input1.txt
  * filename = input2.txt
  * filename = input3.txt
==> passed

Test 7: check for dependence on either compareTo() or compare()
        returning { -1, +1, 0 } instead of { negative integer,
        positive integer, zero }
  * filename = equidistant.txt
    - segments() contains the same segment more than once
    - segment 1: (10000, 0) -> (0, 30000)
    - segment 3: (10000, 0) -> (0, 30000)

    - number of entries in student   solution: 4
    - number of entries in reference solution: 4
    - 4 extra entries in student solution, including:
      '(18000, 2000) -> (2000, 18000)'

    - 4 missing entries in student solution, including:
      '(30000, 0) -> (20000, 10000) -> (10000, 20000) -> (0, 30000)'


  * filename = input40.txt
    - segments() contains the same segment more than once
    - segment 13: (26000, 8000) -> (1000, 31000)
    - segment 15: (26000, 8000) -> (1000, 31000)

    - number of entries in student   solution: 42
    - number of entries in reference solution: 4
    - 42 extra entries in student solution, including:
      '(22000, 29000) -> (10000, 31000)'

    - 4 missing entries in student solution, including:
      '(2000, 29000) -> (4000, 29000) -> (22000, 29000) -> (28000, 29000)'


  * filename = input48.txt
    - segments() contains the same segment more than once
    - segment 10: (18000, 13000) -> (23000, 29000)
    - segment 20: (18000, 13000) -> (23000, 29000)

    - number of entries in student   solution: 69
    - number of entries in reference solution: 6
    - 69 extra entries in student solution, including:
      '(5000, 29000) -> (17000, 31000)'

    - 6 missing entries in student solution, including:
      '(1000, 26000) -> (9000, 26000) -> (11000, 26000) -> (18000, 26000)'


  * filename = input299.txt
    - segments() contains the same segment more than once
    - segment 58: (29050, 5250) -> (16900, 32700)
    - segment 200: (29050, 5250) -> (16900, 32700)

    - number of entries in student   solution: 534
    - number of entries in reference solution: 6
    - 534 extra entries in student solution, including:
      '(600, 31900) -> (1000, 32650)'

    - 6 missing entries in student solution, including:
      '(3250, 17450) -> (8500, 17450) -> (13400, 17450) -> (17250, 17450)'


==> FAILED

Test 8: check for fragile dependence on return value of toString()
  * filename = equidistant.txt
    - segments() contains the same segment more than once
    - segment 1: (10000, 0) -> (0, 30000)
    - segment 3: (10000, 0) -> (0, 30000)

    - number of entries in student   solution: 4
    - number of entries in reference solution: 4
    - 4 extra entries in student solution, including:
      '(18000, 2000) -> (2000, 18000)'

    - 4 missing entries in student solution, including:
      '(30000, 0) -> (20000, 10000) -> (10000, 20000) -> (0, 30000)'


  * filename = input40.txt
    - segments() contains the same segment more than once
    - segment 13: (26000, 8000) -> (1000, 31000)
    - segment 15: (26000, 8000) -> (1000, 31000)

    - number of entries in student   solution: 42
    - number of entries in reference solution: 4
    - 42 extra entries in student solution, including:
      '(22000, 29000) -> (10000, 31000)'

    - 4 missing entries in student solution, including:
      '(2000, 29000) -> (4000, 29000) -> (22000, 29000) -> (28000, 29000)'


  * filename = input48.txt
    - segments() contains the same segment more than once
    - segment 10: (18000, 13000) -> (23000, 29000)
    - segment 20: (18000, 13000) -> (23000, 29000)

    - number of entries in student   solution: 69
    - number of entries in reference solution: 6
    - 69 extra entries in student solution, including:
      '(5000, 29000) -> (17000, 31000)'

    - 6 missing entries in student solution, including:
      '(1000, 26000) -> (9000, 26000) -> (11000, 26000) -> (18000, 26000)'



It is bad style to write code that depends on the particular format of
the output from the toString() method, especially if your reason for
doing so is to circumvent the public API (which intentionally does not
provide access to the x- and y-coordinates).

==> FAILED

Test 9: random line segments, none vertical or horizontal
  *  1 random line segment
    - segments() contains a subsegment of a segment in reference solution
    - student   segment 0: (4536, 9323) -> (5256, 10475)
    - reference segment 0: (4536, 9323) -> (5256, 10475) -> (8136, 15083) -> (9576, 17387)

    - number of entries in student   solution: 1
    - number of entries in reference solution: 1
    - 1 extra entry in student solution:
      '(4536, 9323) -> (5256, 10475)'

    - 1 missing entry in student solution:
      '(4536, 9323) -> (5256, 10475) -> (8136, 15083) -> (9576, 17387)'


    - failed on trial 1 of 500
     4
      5256 10475
      9576 17387
      8136 15083
      4536  9323

  *  5 random line segments
    - segments() contains a subsegment of a segment in reference solution
    - student   segment 2: (2339, 9768) -> (12923, 15648)
    - reference segment 2: (1457, 9278) -> (2339, 9768) -> (4103, 10748) -> (12923, 15648)

    - number of entries in student   solution: 5
    - number of entries in reference solution: 5
    - 1 extra entry in student solution:
      '(2339, 9768) -> (12923, 15648)'

    - 1 missing entry in student solution:
      '(1457, 9278) -> (2339, 9768) -> (4103, 10748) -> (12923, 15648)'


    - failed on trial 2 of 500
     20
      4809  4658
     21184  9778
     13363  7600
       328  3970
     17308 13074
      4288  7194
     13896 15682
     15572 12290
      5508  5506
      8774  9467
      4103 10748
      8304  8898
     10802 10735
      2339  9768
     12923 15648
     12968 11114
      3197  5980
      1197  4212
      9281  9784
      1457  9278

  * 25 random line segments
    - segments() contains a subsegment of a segment in reference solution
    - student   segment 0: (7732, 7237) -> (15796, 7475)
    - reference segment 0: (3124, 7101) -> (7732, 7237) -> (8308, 7254) -> (15796, 7475)

    - number of entries in student   solution: 25
    - number of entries in reference solution: 25
    - 7 extra entries in student solution, including:
      '(6593, 12538) -> (8330, 15130)'

    - 7 missing entries in student solution, including:
      '(5130, 10792) -> (5320, 11302) -> (5814, 12628) -> (6441, 14311)'


    - failed on trial 1 of 100

  * 50 random line segments
    - segments() contains a subsegment of a segment in reference solution
    - student   segment 1: (14070, 13206) -> (17198, 13434)
    - reference segment 1: (12506, 13092) -> (14070, 13206) -> (16416, 13377) -> (17198, 13434)

    - number of entries in student   solution: 50
    - number of entries in reference solution: 50
    - 18 extra entries in student solution, including:
      '(14963, 17486) -> (19793, 20866)'

    - 18 missing entries in student solution, including:
      '(13031, 16134) -> (14963, 17486) -> (17861, 19514) -> (19793, 20866)'


    - failed on trial 1 of 15

  * 100 random line segments
    - segments() contains a subsegment of a segment in reference solution
    - student   segment 1: (11122, 12794) -> (18202, 12866)
    - reference segment 0: (7582, 12758) -> (11122, 12794) -> (14662, 12830) -> (18202, 12866)

    - number of entries in student   solution: 103
    - number of entries in reference solution: 100
    - 24 extra entries in student solution, including:
      '(8990, 16237) -> (11662, 16237)'

    - 21 missing entries in student solution, including:
      '(6313, 13337) -> (9437, 13633) -> (11780, 13855) -> (14904, 14151)'


    - failed on trial 1 of 2

==> FAILED

Test 10: random line segments
  *  1 random line segment
    - segments() contains a subsegment of a segment in reference solution
    - student   segment 0: (6558, 9535) -> (6816, 9637)
    - reference segment 0: (6558, 9535) -> (6816, 9637) -> (8149, 10164) -> (8321, 10232)

    - number of entries in student   solution: 1
    - number of entries in reference solution: 1
    - 1 extra entry in student solution:
      '(6558, 9535) -> (6816, 9637)'

    - 1 missing entry in student solution:
      '(6558, 9535) -> (6816, 9637) -> (8149, 10164) -> (8321, 10232)'


    - failed on trial 1 of 500
     4
      6558  9535
      8149 10164
      8321 10232
      6816  9637

  *  5 random line segments
    - segments() contains a subsegment of a segment in reference solution
    - student   segment 3: (4516, 5892) -> (5524, 10512)
    - reference segment 3: (4444, 5562) -> (4516, 5892) -> (5464, 10237) -> (5524, 10512)

    - number of entries in student   solution: 5
    - number of entries in reference solution: 5
    - 1 extra entry in student solution:
      '(4516, 5892) -> (5524, 10512)'

    - 1 missing entry in student solution:
      '(4444, 5562) -> (4516, 5892) -> (5464, 10237) -> (5524, 10512)'


    - failed on trial 1 of 500
     20
      8322 10008
     10023 11478
      6864  8748
     12087 13719
      7453  4749
      7399  4218
      4956  6533
      7723  7404
      5464 10237
     10266 11688
      3781  4383
      7651  6696
      4516  5892
     11121 13467
     11466 13557
      5524 10512
     12064 13713
      4444  5562
      5238  7049
      4392  5501

  * 25 random line segments
    - segments() contains a subsegment of a segment in reference solution
    - student   segment 3: (3294, 13017) -> (5634, 13317)
    - reference segment 4: (1188, 12747) -> (3294, 13017) -> (4932, 13227) -> (5634, 13317)

    - number of entries in student   solution: 24
    - number of entries in reference solution: 25
    - 5 extra entries in student solution, including:
      '(3294, 13017) -> (5634, 13317)'

    - 6 missing entries in student solution, including:
      '(1188, 12747) -> (3294, 13017) -> (4932, 13227) -> (5634, 13317)'


    - failed on trial 1 of 100

  * 50 random line segments
    - segments() contains a subsegment of a segment in reference solution
    - student   segment 2: (10128, 7364) -> (11752, 7567)
    - reference segment 3: (9456, 7280) -> (10128, 7364) -> (11696, 7560) -> (11752, 7567)

    - number of entries in student   solution: 45
    - number of entries in reference solution: 50
    - 14 extra entries in student solution, including:
      '(3920, 12329) -> (4770, 12975)'

    - 19 missing entries in student solution, including:
      '(13799, 12912) -> (13799, 14012) -> (13799, 14232) -> (13799, 14292)'


    - failed on trial 1 of 15

  * 100 random line segments
    - segments() contains a subsegment of a segment in reference solution
    - student   segment 3: (5383, 10982) -> (9583, 11222)
    - reference segment 17: (2933, 10842) -> (5383, 10982) -> (6713, 11058) -> (9583, 11222)

    - number of entries in student   solution: 75
    - number of entries in reference solution: 100
    - 27 extra entries in student solution, including:
      '(9870, 14251) -> (8506, 14871)'

    - 52 missing entries in student solution, including:
      '(7898, 14871) -> (8506, 14871) -> (8602, 14871) -> (8826, 14871)'


    - failed on trial 1 of 2

==> FAILED

Test 11: random distinct points in a given range
  * 5 random points in a 10-by-10 grid
    - segments() contains a subsegment of a segment in reference solution
    - student   segment 0: (9, 1) -> (6, 4)
    - reference segment 0: (9, 1) -> (8, 2) -> (6, 4) -> (2, 8)

    - number of entries in student   solution: 1
    - number of entries in reference solution: 1
    - 1 extra entry in student solution:
      '(9, 1) -> (6, 4)'

    - 1 missing entry in student solution:
      '(9, 1) -> (8, 2) -> (6, 4) -> (2, 8)'


    - failed on trial 142 of 500
     5
         1     5
         6     4
         9     1
         8     2
         2     8

  * 10 random points in a 10-by-10 grid
    - number of entries in student   solution: 2
    - number of entries in reference solution: 0
    - 2 extra entries in student solution, including:
      '(0, 7) -> (5, 9)'


    - failed on trial 1 of 500
     10
         3     7
         6     8
         0     7
         5     0
         5     7
         4     0
         6     5
         4     9
         5     9
         6     6

  * 50 random points in a 10-by-10 grid
    - segments() contains the same segment more than once
    - segment 1: (2, 1) -> (8, 9)
    - segment 5: (2, 1) -> (8, 9)

    - segments() contains a subsegment of a segment in reference solution
    - student   segment 40: (3, 2) -> (9, 8)
    - reference segment 15: (2, 1) -> (3, 2) -> (4, 3) -> (7, 6) -> (9, 8)

    - number of entries in student   solution: 74
    - number of entries in reference solution: 33
    - 69 extra entries in student solution, including:
      '(0, 7) -> (9, 8)'

    - 28 missing entries in student solution, including:
      '(0, 9) -> (2, 9) -> (3, 9) -> (4, 9) -> (5, 9) -> (6, 9) -> (8, 9)'


    - failed on trial 1 of 100

  * 90 random points in a 10-by-10 grid
    - segments() contains the same segment more than once
    - segment 2: (2, 0) -> (8, 9)
    - segment 3: (2, 0) -> (8, 9)

    - segments() contains a subsegment of a segment in reference solution
    - student   segment 25: (8, 1) -> (1, 8)
    - reference segment 24: (9, 0) -> (8, 1) -> (7, 2) -> (6, 3) -> (5, 4) -> (4, 5) -> (3, 6) -> (2, 7) -> (1, 8) -> (0, 9)

    - number of entries in student   solution: 103
    - number of entries in reference solution: 124
    - 93 extra entries in student solution, including:
      '(9, 3) -> (0, 9)'

    - 114 missing entries in student solution, including:
      '(0, 9) -> (2, 9) -> (4, 9) -> (5, 9) -> (6, 9) -> (7, 9) -> (8, 9) -> (9, 9)'


    - failed on trial 1 of 50

  * 200 random points in a 50-by-50 grid
    - segments() contains the same segment more than once
    - segment 11: (40, 1) -> (39, 49)
    - segment 17: (40, 1) -> (39, 49)

    - segments() contains a subsegment of a segment in reference solution
    - student   segment 42: (36, 6) -> (36, 44)
    - reference segment 218: (36, 1) -> (36, 6) -> (36, 23) -> (36, 44)

    - number of entries in student   solution: 1371
    - number of entries in reference solution: 227
    - 1353 extra entries in student solution, including:
      '(1, 47) -> (38, 49)'

    - 209 missing entries in student solution, including:
      '(18, 49) -> (29, 49) -> (38, 49) -> (39, 49)'


    - failed on trial 1 of 10

==> FAILED

Test 12: m*n points on an m-by-n grid
  * 3-by-3 grid
    - segments() contains the same segment more than once
    - segment 2: (0, 0) -> (2, 2)
    - segment 3: (0, 0) -> (2, 2)

    - number of entries in student   solution: 4
    - number of entries in reference solution: 0
    - 4 extra entries in student solution, including:
      '(0, 1) -> (2, 2)'


  * 4-by-4 grid
    - segments() contains the same segment more than once
    - segment 0: (2, 0) -> (2, 3)
    - segment 1: (2, 0) -> (2, 3)

    - number of entries in student   solution: 8
    - number of entries in reference solution: 10
    - 6 extra entries in student solution, including:
      '(3, 1) -> (1, 3)'

    - 8 missing entries in student solution, including:
      '(0, 3) -> (1, 3) -> (2, 3) -> (3, 3)'


  * 5-by-5 grid
    - segments() contains the same segment more than once
    - segment 2: (1, 0) -> (3, 4)
    - segment 4: (1, 0) -> (3, 4)

    - number of entries in student   solution: 20
    - number of entries in reference solution: 16
    - 18 extra entries in student solution, including:
      '(4, 3) -> (0, 4)'

    - 14 missing entries in student solution, including:
      '(0, 4) -> (1, 4) -> (2, 4) -> (3, 4) -> (4, 4)'


  * 10-by-10 grid
    - segments() contains the same segment more than once
    - segment 1: (3, 0) -> (8, 9)
    - segment 2: (3, 0) -> (8, 9)

    - segments() contains a subsegment of a segment in reference solution
    - student   segment 26: (9, 0) -> (1, 8)
    - reference segment 33: (9, 0) -> (8, 1) -> (7, 2) -> (6, 3) -> (5, 4) -> (4, 5) -> (3, 6) -> (2, 7) -> (1, 8) -> (0, 9)

    - number of entries in student   solution: 104
    - number of entries in reference solution: 154
    - 93 extra entries in student solution, including:
      '(9, 2) -> (0, 9)'

    - 143 missing entries in student solution, including:
      '(0, 9) -> (1, 9) -> (2, 9) -> (3, 9) -> (4, 9) -> (5, 9) -> (6, 9) -> (7, 9) -> (8, 9) -> (9, 9)'


  * 20-by-20 grid
    - segments() contains the same segment more than once
    - segment 1: (3, 0) -> (18, 19)
    - segment 2: (3, 0) -> (18, 19)

    - number of entries in student   solution: 472
    - number of entries in reference solution: 2446
    - 467 extra entries in student solution, including:
      '(19, 3) -> (0, 19)'

    - 2441 missing entries in student solution, including:
      '(0, 19) -> (1, 19) -> (2, 19) -> (3, 19) -> (4, 19) -> (5, 19) -> (6, 19) -> (7, 19) -> (8, 19) -> (9, 19) -> (10, 19) -> (11, 19) -> (12, 19) -> (13, 19) -> (14, 19) -> (15, 19) -> (16, 19) -> (17, 19) -> (18, 19) -> (19, 19)'


  * 5-by-4 grid
    - segments() contains the same segment more than once
    - segment 1: (1, 0) -> (3, 3)
    - segment 2: (1, 0) -> (3, 3)

    - number of entries in student   solution: 14
    - number of entries in reference solution: 13
    - 13 extra entries in student solution, including:
      '(4, 1) -> (1, 3)'

    - 12 missing entries in student solution, including:
      '(0, 3) -> (1, 3) -> (2, 3) -> (3, 3) -> (4, 3)'


  * 6-by-4 grid
    - segments() contains the same segment more than once
    - segment 8: (0, 0) -> (5, 3)
    - segment 13: (0, 0) -> (5, 3)

    - number of entries in student   solution: 18
    - number of entries in reference solution: 16
    - 15 extra entries in student solution, including:
      '(5, 1) -> (1, 3)'

    - 13 missing entries in student solution, including:
      '(0, 3) -> (1, 3) -> (2, 3) -> (3, 3) -> (4, 3) -> (5, 3)'


  * 10-by-4 grid
    - segments() contains the same segment more than once
    - segment 1: (1, 0) -> (8, 3)
    - segment 3: (1, 0) -> (8, 3)

    - number of entries in student   solution: 34
    - number of entries in reference solution: 38
    - 33 extra entries in student solution, including:
      '(9, 1) -> (1, 3)'

    - 37 missing entries in student solution, including:
      '(0, 3) -> (1, 3) -> (2, 3) -> (3, 3) -> (4, 3) -> (5, 3) -> (6, 3) -> (7, 3) -> (8, 3) -> (9, 3)'


  * 15-by-4 grid
    - segments()

...

WARNING: the grading output was truncated due to excessive length.
Typically, this is because you have a method that has an unanticipated side effect
(such as printing to standard output or throwing an exception). A large amount of output
can also arise from failing many tests.
