See the Assessment Guide for information on how to interpret this report.

ASSESSMENT SUMMARY

Compilation:  PASSED
API:          PASSED

Spotbugs:     FAILED (13 warnings)
PMD:          FAILED (14 warnings)
Checkstyle:   FAILED (0 errors, 4 warnings)

Correctness:  12/41 tests passed
Memory:       1/1 tests passed
Timing:       6/41 tests passed

Aggregate score: 40.49%
[Compilation: 5%, API: 5%, Spotbugs: 0%, PMD: 0%, Checkstyle: 0%, Correctness: 60%, Memory: 10%, Timing: 20%]

ASSESSMENT DETAILS

The following files were submitted:
----------------------------------
5.7K Jan  5 23:52 BruteCollinearPoints.java
4.5K Jan  5 23:52 FastCollinearPoints.java
4.3K Jan  5 23:52 Point.java


********************************************************************************
*  COMPILING
********************************************************************************


% javac11 Point.java
*-----------------------------------------------------------

% javac11 LineSegment.java
*-----------------------------------------------------------

% javac11 BruteCollinearPoints.java
*-----------------------------------------------------------

% javac11 FastCollinearPoints.java
*-----------------------------------------------------------


================================================================


Checking the APIs of your programs.
*-----------------------------------------------------------
Point:

BruteCollinearPoints:

FastCollinearPoints:

================================================================


********************************************************************************
*  CHECKING STYLE AND COMMON BUG PATTERNS
********************************************************************************


% spotbugs *.class
*-----------------------------------------------------------
M D UC_USELESS_OBJECT UC: The object stored in the variable 'pt' is created and modified, but its value never goes outside of the method 'main()' or produces any side effect.  At Point.java:[line 133]
M D UC_USELESS_OBJECT UC: The object stored in the variable 'pt2' is created and modified, but its value never goes outside of the method 'main()' or produces any side effect.  At Point.java:[line 134]
M D DLS_DEAD_LOCAL_STORE DLS: Assigns a value to the local variable 'slopeResult' but that value is never used.  At Point.java:[line 136]
M D DLS_DEAD_LOCAL_STORE DLS: Assigns a value to the local variable 'comparator' but that value is never used.  At Point.java:[line 137]
M D DLS_DEAD_LOCAL_STORE DLS: Assigns a value to the local variable 'compareResult' but that value is never used.  At Point.java:[line 135]
L D FE_FLOATING_POINT_EQUALITY FE: Tests for exact floating-point equality. Because floating-point calculations may involve rounding, the calculated values may be imprecise.  At Point.java:[line 68]
H D UC_USELESS_VOID_METHOD UC: The void method 'main()' appears to serve no purpose.  At Point.java:[line 139]
M V EI_EXPOSE_REP2 EI2: Stores a reference to an externally mutable object in the instance variable 'points', exposing the internal representation of the class 'BruteCollinearPoints'. Instead, create a defensive copy of the object referenced by the parameter variable 'points' and store that copy in the instance variable 'points'.  At BruteCollinearPoints.java:[line 23]
M V EI_EXPOSE_REP2 EI2: Stores a reference to an externally mutable object in the instance variable 'points', exposing the internal representation of the class 'FastCollinearPoints'. Instead, create a defensive copy of the object referenced by the parameter variable 'points' and store that copy in the instance variable 'points'.  At FastCollinearPoints.java:[line 23]
L D FE_FLOATING_POINT_EQUALITY FE: Tests for exact floating-point equality. Because floating-point calculations may involve rounding, the calculated values may be imprecise.  At FastCollinearPoints.java:[line 79]
L P SIC_INNER_SHOULD_BE_STATIC_ANON SIC: Should the anonymous inner class 'BruteCollinearPoints$1' be refactored into a named static nested class?  At BruteCollinearPoints.java:[line 107]
L P SIC_INNER_SHOULD_BE_STATIC_ANON SIC: Should the anonymous inner class 'FastCollinearPoints$1' be refactored into a named static nested class?  At FastCollinearPoints.java:[line 96]
L P SIC_INNER_SHOULD_BE_STATIC_ANON SIC: Should the anonymous inner class 'BruteCollinearPoints$2' be refactored into a named static nested class?  At BruteCollinearPoints.java:[line 115]
Warnings generated: 13


================================================================


% pmd .
*-----------------------------------------------------------
BruteCollinearPoints.java:17: The private instance (or static) variable 'points' can be made 'final'; it is initialized only in the declaration or constructor. [ImmutableField]
BruteCollinearPoints.java:19: The user-supplied array 'points' is stored directly. [ArrayIsStoredDirectly]
BruteCollinearPoints.java:42: The private instance (or static) variable 'origin' can be made 'final'; it is initialized only in the declaration or constructor. [ImmutableField]
BruteCollinearPoints.java:43: The private instance (or static) variable 'point' can be made 'final'; it is initialized only in the declaration or constructor. [ImmutableField]
BruteCollinearPoints.java:44: The private instance (or static) variable 'slopeToOrigin' can be made 'final'; it is initialized only in the declaration or constructor. [ImmutableField]
BruteCollinearPoints.java:85: Avoid unused local variables, such as 'prevSlope'. [UnusedLocalVariable]
FastCollinearPoints.java:17: The private instance (or static) variable 'points' can be made 'final'; it is initialized only in the declaration or constructor. [ImmutableField]
FastCollinearPoints.java:19: The user-supplied array 'points' is stored directly. [ArrayIsStoredDirectly]
FastCollinearPoints.java:39: The private instance (or static) variable 'origin' can be made 'final'; it is initialized only in the declaration or constructor. [ImmutableField]
FastCollinearPoints.java:40: The private instance (or static) variable 'point' can be made 'final'; it is initialized only in the declaration or constructor. [ImmutableField]
FastCollinearPoints.java:41: The private instance (or static) variable 'slopeToOrigin' can be made 'final'; it is initialized only in the declaration or constructor. [ImmutableField]
Point.java:135: Avoid unused local variables, such as 'compareResult'. [UnusedLocalVariable]
Point.java:136: Avoid unused local variables, such as 'slopeResult'. [UnusedLocalVariable]
Point.java:137: Avoid unused local variables, such as 'comparator'. [UnusedLocalVariable]
PMD ends with 14 warnings.


================================================================


% checkstyle *.java
*-----------------------------------------------------------

% custom checkstyle checks for Point.java
*-----------------------------------------------------------

% custom checkstyle checks for BruteCollinearPoints.java
*-----------------------------------------------------------
[WARN] BruteCollinearPoints.java:15:1: Defining a nested class in this program suggests poor design. [Design]
[WARN] BruteCollinearPoints.java:83:73: The numeric literal '6' appears to be unnecessary. [NumericLiteral]
[WARN] BruteCollinearPoints.java:89:31: The numeric literal '6' appears to be unnecessary. [NumericLiteral]
Checkstyle ends with 0 errors and 3 warnings.

% custom checkstyle checks for FastCollinearPoints.java
*-----------------------------------------------------------
[WARN] FastCollinearPoints.java:15:1: Defining a nested class in this program suggests poor design. [Design]
Checkstyle ends with 0 errors and 1 warning.


================================================================


********************************************************************************
*  TESTING CORRECTNESS
********************************************************************************

Testing correctness of Point
*-----------------------------------------------------------
Running 3 total tests.

Test 1: p.slopeTo(q)
  * positive infinite slope, where p and q have coordinates in [0, 500)
  * positive infinite slope, where p and q have coordinates in [0, 32768)
  * negative infinite slope, where p and q have coordinates in [0, 500)
  * negative infinite slope, where p and q have coordinates in [0, 32768)
  * positive zero     slope, where p and q have coordinates in [0, 500)
  * positive zero     slope, where p and q have coordinates in [0, 32768)
  * symmetric for random points p and q with coordinates in [0, 500)
  * symmetric for random points p and q with coordinates in [0, 32768)
  * transitive for random points p, q, and r with coordinates in [0, 500)
  * transitive for random points p, q, and r with coordinates in [0, 32768)
  * slopeTo(), where p and q have coordinates in [0, 500)
  * slopeTo(), where p and q have coordinates in [0, 32768)
  * slopeTo(), where p and q have coordinates in [0, 10)
  * throw a java.lang.NullPointerException if argument is null
==> passed

Test 2: p.compareTo(q)
  * reflexive, where p and q have coordinates in [0, 500)
  * reflexive, where p and q have coordinates in [0, 32768)
  * antisymmetric, where p and q have coordinates in [0, 500)
  * antisymmetric, where p and q have coordinates in [0, 32768)
  * transitive, where p, q, and r have coordinates in [0, 500)
  * transitive, where p, q, and r have coordinates in [0, 32768)
  * sign of compareTo(), where p and q have coordinates in [0, 500)
  * sign of compareTo(), where p and q have coordinates in [0, 32768)
  * sign of compareTo(), where p and q have coordinates in [0, 10)
  * throw java.lang.NullPointerException exception if argument is null
==> passed

Test 3: p.slopeOrder().compare(q, r)
  * reflexive, where p and q have coordinates in [0, 500)
  * reflexive, where p and q have coordinates in [0, 32768)
  * antisymmetric, where p, q, and r have coordinates in [0, 500)
  * antisymmetric, where p, q, and r have coordinates in [0, 32768)
  * transitive, where p, q, r, and s have coordinates in [0, 500)
  * transitive, where p, q, r, and s have coordinates in [0, 32768)
  * sign of compare(), where p, q, and r have coordinates in [0, 500)
  * sign of compare(), where p, q, and r have coordinates in [0, 32768)
  * sign of compare(), where p, q, and r have coordinates in [0, 10)
  * throw java.lang.NullPointerException if either argument is null
==> passed


Total: 3/3 tests passed!


================================================================
********************************************************************************
*  TESTING CORRECTNESS (substituting reference Point and LineSegment)
********************************************************************************

Testing correctness of BruteCollinearPoints
*-----------------------------------------------------------
Running 17 total tests.

The inputs satisfy the following conditions:
  - no duplicate points
  - no 5 (or more) points are collinear
  - all x- and y-coordinates between 0 and 32,767

Test 1: points from a file
  * filename = input8.txt
    - segments() contains a subsegment of a segment in reference solution
    - student   segment 0: (10000, 0) -> (7000, 3000)
    - reference segment 0: (10000, 0) -> (7000, 3000) -> (3000, 7000) -> (0, 10000)

    - number of entries in student   solution: 5
    - number of entries in reference solution: 2
    - 5 extra entries in student solution, including:
      '(10000, 0) -> (20000, 21000)'

    - 2 missing entries in student solution, including:
      '(3000, 4000) -> (6000, 7000) -> (14000, 15000) -> (20000, 21000)'


  * filename = equidistant.txt
    - segments() contains a subsegment of a segment in reference solution
    - student   segment 1: (10000, 0) -> (20000, 0)
    - reference segment 3: (10000, 0) -> (13000, 0) -> (20000, 0) -> (30000, 0)

    - number of entries in student   solution: 5
    - number of entries in reference solution: 4
    - 3 extra entries in student solution, including:
      '(10000, 0) -> (10000, 20000)'

    - 2 missing entries in student solution, including:
      '(30000, 0) -> (20000, 10000) -> (10000, 20000) -> (0, 30000)'


  * filename = input40.txt
    - number of entries in student   solution: 5
    - number of entries in reference solution: 4
    - 5 extra entries in student solution, including:
      '(19000, 2000) -> (10000, 28000)'

    - 4 missing entries in student solution, including:
      '(2000, 29000) -> (4000, 29000) -> (22000, 29000) -> (28000, 29000)'


  * filename = input48.txt
    - number of entries in student   solution: 5
    - number of entries in reference solution: 6
    - 5 extra entries in student solution, including:
      '(6000, 0) -> (25000, 25000)'

    - 6 missing entries in student solution, including:
      '(1000, 26000) -> (9000, 26000) -> (11000, 26000) -> (18000, 26000)'


==> FAILED

Test 2a: points from a file with horizontal line segments
  * filename = horizontal5.txt
    - segments() contains a subsegment of a segment in reference solution
    - student   segment 1: (4750, 4652) -> (5766, 4652)
    - reference segment 0: (4750, 4652) -> (5766, 4652) -> (9972, 4652) -> (16307, 4652)

    - number of entries in student   solution: 5
    - number of entries in reference solution: 5
    - 4 extra entries in student solution, including:
      '(4750, 4652) -> (7821, 14118)'

    - 4 missing entries in student solution, including:
      '(2682, 14118) -> (5067, 14118) -> (7453, 14118) -> (7821, 14118)'


  * filename = horizontal25.txt

    java.lang.OutOfMemoryError: Java heap space

    java.base/java.util.Arrays.copyOf(Arrays.java:3720)
    java.base/java.util.Arrays.copyOf(Arrays.java:3689)
    java.base/java.util.ArrayList.grow(ArrayList.java:237)
    java.base/java.util.ArrayList.grow(ArrayList.java:242)
    java.base/java.util.ArrayList.add(ArrayList.java:485)
    ...
    BruteCollinearPoints.segments(BruteCollinearPoints.java:67)
    TestBruteCollinearPoints.testSegments(TestBruteCollinearPoints.java:109)
    TestBruteCollinearPoints.file(TestBruteCollinearPoints.java:150)
    TestBruteCollinearPoints.test2a(TestBruteCollinearPoints.java:165)
    TestBruteCollinearPoints.main(TestBruteCollinearPoints.java:720)

==> FAILED

Test 2b: random horizontal line segments
  *  1 random horizontal line segment
    - segments() contains a subsegment of a segment in reference solution
    - student   segment 1: (7959, 14192) -> (17637, 14192)
    - reference segment 0: (7959, 14192) -> (10630, 14192) -> (17637, 14192) -> (20941, 14192)

    - number of entries in student   solution: 2
    - number of entries in reference solution: 1
    - 1 extra entry in student solution:
      '(7959, 14192) -> (17637, 14192)'


    - failed on trial 1 of 500
     4
      7959 14192
     17637 14192
     20941 14192
     10630 14192

  *  5 random horizontal line segments
    - number of entries in student   solution: 5
    - number of entries in reference solution: 5
    - 4 extra entries in student solution, including:
      '(5140, 1569) -> (13554, 20850)'

    - 4 missing entries in student solution, including:
      '(3288, 20850) -> (5354, 20850) -> (13554, 20850) -> (16217, 20850)'


    - failed on trial 1 of 250
     20
     11250 18753
      4895  7777
     13554 20850
     19198 18753
      1060 13793
      5140  1569
     15333 13793
     14624  1569
      7306 18753
      2577  7777
     12557 18753
      7748  1569
     16217 20850
     13063 13793
      5354 20850
      1182  7777
     11260  1569
      3288 20850
     20455  7777
     15354 13793

  * 10 random horizontal line segments
    - number of entries in student   solution: 5
    - number of entries in reference solution: 10
    - 4 extra entries in student solution, including:
      '(11191, 1041) -> (13067, 20610)'

    - 9 missing entries in student solution, including:
      '(5807, 20610) -> (13067, 20610) -> (14223, 20610) -> (15193, 20610)'


    - failed on trial 1 of 50

  * 15 random horizontal line segments
    - number of entries in student   solution: 5
    - number of entries in reference solution: 15
    - 5 extra entries in student solution, including:
      '(2507, 2755) -> (16304, 20052)'

    - 15 missing entries in student solution, including:
      '(7657, 20755) -> (8080, 20755) -> (12138, 20755) -> (13994, 20755)'


    - failed on trial 1 of 5

==> FAILED

Test 3a: points from a file with vertical line segments
  * filename = vertical5.txt
    - number of entries in student   solution: 5
    - number of entries in reference solution: 5
    - 5 extra entries in student solution, including:
      '(8421, 1829) -> (14407, 17188)'

    - 5 missing entries in student solution, including:
      '(14407, 10367) -> (14407, 17188) -> (14407, 17831) -> (14407, 19953)'


  * filename = vertical25.txt

    java.lang.OutOfMemoryError: Java heap space

    java.base/java.util.Arrays.copyOf(Arrays.java:3720)
    java.base/java.util.Arrays.copyOf(Arrays.java:3689)
    java.base/java.util.ArrayList.grow(ArrayList.java:237)
    java.base/java.util.ArrayList.grow(ArrayList.java:242)
    java.base/java.util.ArrayList.add(ArrayList.java:485)
    ...
    BruteCollinearPoints.segments(BruteCollinearPoints.java:67)
    TestBruteCollinearPoints.testSegments(TestBruteCollinearPoints.java:109)
    TestBruteCollinearPoints.file(TestBruteCollinearPoints.java:150)
    TestBruteCollinearPoints.test3a(TestBruteCollinearPoints.java:229)
    TestBruteCollinearPoints.main(TestBruteCollinearPoints.java:726)

==> FAILED

Test 3b: random vertical line segments
  *  1 random vertical line segment
    - segments() contains a subsegment of a segment in reference solution
    - student   segment 1: (9154, 15465) -> (9154, 16512)
    - reference segment 0: (9154, 15465) -> (9154, 16091) -> (9154, 16512) -> (9154, 18854)

    - number of entries in student   solution: 2
    - number of entries in reference solution: 1
    - 1 extra entry in student solution:
      '(9154, 15465) -> (9154, 16512)'


    - failed on trial 1 of 500
     4
      9154 16512
      9154 18854
      9154 16091
      9154 15465

  *  5 random vertical line segments
    - number of entries in student   solution: 5
    - number of entries in reference solution: 5
    - 4 extra entries in student solution, including:
      '(6380, 1059) -> (13412, 19544)'

    - 4 missing entries in student solution, including:
      '(2177, 9693) -> (2177, 14918) -> (2177, 18215) -> (2177, 20205)'


    - failed on trial 1 of 250
     20
      6380 15152
      1799 12174
      2177  9693
      1799  3990
     13412  6828
      6380 17063
      9372  3451
     13412 19544
      9372 11098
      1799  9149
     13412  9035
      2177 14918
      9372 17444
     13412  5849
      9372 14045
      2177 18215
      1799  2775
      6380  1059
      6380 13141
      2177 20205

  * 10 random vertical line segments
    - number of entries in student   solution: 5
    - number of entries in reference solution: 10
    - 5 extra entries in student solution, including:
      '(10331, 1235) -> (5341, 14358)'

    - 10 missing entries in student solution, including:
      '(3666, 10082) -> (3666, 10686) -> (3666, 13750) -> (3666, 20971)'


    - failed on trial 1 of 50

  * 15 random vertical line segments
    - segments() contains a subsegment of a segment in reference solution
    - student   segment 4: (12247, 1087) -> (12247, 10662)
    - reference segment 8: (12247, 1087) -> (12247, 1206) -> (12247, 10662) -> (12247, 13453)

    - number of entries in student   solution: 5
    - number of entries in reference solution: 15
    - 5 extra entries in student solution, including:
      '(12247, 1087) -> (8338, 20986)'

    - 15 missing entries in student solution, including:
      '(7228, 9025) -> (7228, 11609) -> (7228, 14033) -> (7228, 14217)'


    - failed on trial 1 of 5

==> FAILED

Test 4a: points from a file with no line segments
  * filename = random23.txt
    - number of entries in student   solution: 5
    - number of entries in reference solution: 0
    - 5 extra entries in student solution, including:
      '(1738, 1685) -> (14224, 31579)'


  * filename = random38.txt
    - number of entries in student   solution: 5
    - number of entries in reference solution: 0
    - 5 extra entries in student solution, including:
      '(3815, 413) -> (23137, 27386)'


==> FAILED

Test 4b: random points with no line segments
  *  5 random points
    - number of entries in student   solution: 2
    - number of entries in reference solution: 0
    - 2 extra entries in student solution, including:
      '(5539, 1627) -> (24282, 32172)'


    - failed on trial 1 of 500
     5
     15041 10208
     11703 21014
      5539  1627
      4052  2545
     24282 32172

  * 10 random points
    - number of entries in student   solution: 5
    - number of entries in reference solution: 0
    - 5 extra entries in student solution, including:
      '(22014, 2228) -> (17205, 26456)'


    - failed on trial 1 of 250
     10
     22014  2228
     24872 26840
      8416  6661
     17205 26456
     21163  3906
     18216 31304
     10924 23132
     24491 13170
      1603 23975
     23639  7539

  * 20 random points
    - number of entries in student   solution: 5
    - number of entries in reference solution: 0
    - 5 extra entries in student solution, including:
      '(20144, 2909) -> (4596, 19689)'


    - failed on trial 1 of 100
     20
     32115 14382
     26351 23097
     20144  2909
     24319 10548
     17508 11982
      4596 19689
     14579 13696
     16101 12754
     30236  7047
     30454  3348
     26626 32748
     16256  8498
     12090 32098
     26852 25019
     18445 27109
      4514 28406
     11631 21575
     32137 10313
      6343 20701
     27677 16722

  * 50 random points
    - number of entries in student   solution: 5
    - number of entries in reference solution: 0
    - 5 extra entries in student solution, including:
      '(9583, 66) -> (18204, 29988)'


    - failed on trial 1 of 10

==> FAILED

Test 5: points from a file with fewer than 4 points
  * filename = input1.txt

    java.lang.NullPointerException

    BruteCollinearPoints$2.compare(BruteCollinearPoints.java:117)
    BruteCollinearPoints$2.compare(BruteCollinearPoints.java:115)
    java.base/java.util.TimSort.countRunAndMakeAscending(TimSort.java:355)
    java.base/java.util.TimSort.sort(TimSort.java:220)
    java.base/java.util.Arrays.sort(Arrays.java:1441)
    ...
    BruteCollinearPoints.segments(BruteCollinearPoints.java:86)
    TestBruteCollinearPoints.testSegments(TestBruteCollinearPoints.java:109)
    TestBruteCollinearPoints.file(TestBruteCollinearPoints.java:150)
    TestBruteCollinearPoints.test5(TestBruteCollinearPoints.java:283)
    TestBruteCollinearPoints.main(TestBruteCollinearPoints.java:738)

  * filename = input2.txt

    java.lang.NullPointerException

    BruteCollinearPoints$2.compare(BruteCollinearPoints.java:117)
    BruteCollinearPoints$2.compare(BruteCollinearPoints.java:115)
    java.base/java.util.TimSort.countRunAndMakeAscending(TimSort.java:355)
    java.base/java.util.TimSort.sort(TimSort.java:220)
    java.base/java.util.Arrays.sort(Arrays.java:1441)
    ...
    BruteCollinearPoints.segments(BruteCollinearPoints.java:86)
    TestBruteCollinearPoints.testSegments(TestBruteCollinearPoints.java:109)
    TestBruteCollinearPoints.file(TestBruteCollinearPoints.java:150)
    TestBruteCollinearPoints.test5(TestBruteCollinearPoints.java:284)
    TestBruteCollinearPoints.main(TestBruteCollinearPoints.java:738)

  * filename = input3.txt

    java.lang.NullPointerException

    BruteCollinearPoints$2.compare(BruteCollinearPoints.java:117)
    BruteCollinearPoints$2.compare(BruteCollinearPoints.java:115)
    java.base/java.util.TimSort.countRunAndMakeAscending(TimSort.java:355)
    java.base/java.util.TimSort.sort(TimSort.java:220)
    java.base/java.util.Arrays.sort(Arrays.java:1441)
    ...
    BruteCollinearPoints.segments(BruteCollinearPoints.java:86)
    TestBruteCollinearPoints.testSegments(TestBruteCollinearPoints.java:109)
    TestBruteCollinearPoints.file(TestBruteCollinearPoints.java:150)
    TestBruteCollinearPoints.test5(TestBruteCollinearPoints.java:285)
    TestBruteCollinearPoints.main(TestBruteCollinearPoints.java:738)

==> FAILED

Test 6: check for dependence on either compareTo() or compare()
        returning { -1, +1, 0 } instead of { negative integer,
        positive integer, zero }
  * filename = equidistant.txt
    - segments() contains a subsegment of a segment in reference solution
    - student   segment 1: (10000, 0) -> (20000, 0)
    - reference segment 3: (10000, 0) -> (13000, 0) -> (20000, 0) -> (30000, 0)

    - number of entries in student   solution: 5
    - number of entries in reference solution: 4
    - 3 extra entries in student solution, including:
      '(10000, 0) -> (10000, 20000)'

    - 2 missing entries in student solution, including:
      '(30000, 0) -> (20000, 10000) -> (10000, 20000) -> (0, 30000)'


  * filename = input40.txt
    - number of entries in student   solution: 5
    - number of entries in reference solution: 4
    - 5 extra entries in student solution, including:
      '(19000, 2000) -> (10000, 28000)'

    - 4 missing entries in student solution, including:
      '(2000, 29000) -> (4000, 29000) -> (22000, 29000) -> (28000, 29000)'


  * filename = input48.txt
    - number of entries in student   solution: 5
    - number of entries in reference solution: 6
    - 5 extra entries in student solution, including:
      '(6000, 0) -> (25000, 25000)'

    - 6 missing entries in student solution, including:
      '(1000, 26000) -> (9000, 26000) -> (11000, 26000) -> (18000, 26000)'


==> FAILED

Test 7: check for fragile dependence on return value of toString()
  * filename = equidistant.txt
    - segments() contains a subsegment of a segment in reference solution
    - student   segment 1: (10000, 0) -> (20000, 0)
    - reference segment 3: (10000, 0) -> (13000, 0) -> (20000, 0) -> (30000, 0)

    - number of entries in student   solution: 5
    - number of entries in reference solution: 4
    - 3 extra entries in student solution, including:
      '(10000, 0) -> (10000, 20000)'

    - 2 missing entries in student solution, including:
      '(30000, 0) -> (20000, 10000) -> (10000, 20000) -> (0, 30000)'


  * filename = input40.txt
    - number of entries in student   solution: 5
    - number of entries in reference solution: 4
    - 5 extra entries in student solution, including:
      '(19000, 2000) -> (10000, 28000)'

    - 4 missing entries in student solution, including:
      '(2000, 29000) -> (4000, 29000) -> (22000, 29000) -> (28000, 29000)'


  * filename = input48.txt
    - number of entries in student   solution: 5
    - number of entries in reference solution: 6
    - 5 extra entries in student solution, including:
      '(6000, 0) -> (25000, 25000)'

    - 6 missing entries in student solution, including:
      '(1000, 26000) -> (9000, 26000) -> (11000, 26000) -> (18000, 26000)'



It is bad style to write code that depends on the particular format of
the output from the toString() method, especially if your reason for
doing so is to circumvent the public API (which intentionally does not
provide access to the x- and y-coordinates).

==> FAILED

Test 8: random line segments, none vertical or horizontal
  *  1 random line segment
    - segments() contains a subsegment of a segment in reference solution
    - student   segment 1: (1530, 3591) -> (5589, 9486)
    - reference segment 0: (1530, 3591) -> (3785, 6866) -> (5589, 9486) -> (11452, 18001)

    - number of entries in student   solution: 2
    - number of entries in reference solution: 1
    - 1 extra entry in student solution:
      '(1530, 3591) -> (5589, 9486)'


    - failed on trial 1 of 500
     4
      5589  9486
      1530  3591
     11452 18001
      3785  6866

  *  5 random line segments
    - segments() contains a subsegment of a segment in reference solution
    - student   segment 1: (4774, 866) -> (6122, 4294)
    - reference segment 3: (4774, 866) -> (5785, 3437) -> (6122, 4294) -> (9492, 12864)

    - number of entries in student   solution: 5
    - number of entries in reference solution: 5
    - 4 extra entries in student solution, including:
      '(4774, 866) -> (13224, 14187)'

    - 4 missing entries in student solution, including:
      '(8056, 9603) -> (12578, 13614) -> (13224, 14187) -> (14516, 15333)'


    - failed on trial 1 of 250
     20
      5785  3437
      4774   866
     14516 15333
      6028  9109
     10271  5668
      6122  4294
     13224 14187
      6336 10237
      9492 12864
      5874  8545
     13328 15092
      8846 10586
      5105  2563
     19304 21100
      8056  9603
     12578 13614
     11993  6703
      2809  1183
      1376  3076
      6721 11647

  * 10 random line segments
    - segments() contains a subsegment of a segment in reference solution
    - student   segment 0: (1408, 1190) -> (7456, 4700)
    - reference segment 3: (1408, 1190) -> (7456, 4700) -> (8128, 5090) -> (10816, 6650)

    - number of entries in student   solution: 5
    - number of entries in reference solution: 10
    - 5 extra entries in student solution, including:
      '(1408, 1190) -> (12670, 20062)'

    - 10 missing entries in student solution, including:
      '(5556, 14556) -> (7440, 15244) -> (7911, 15416) -> (9795, 16104)'


    - failed on trial 1 of 100

  * 15 random line segments
    - number of entries in student   solution: 5
    - number of entries in reference solution: 15
    - 5 extra entries in student solution, including:
      '(6905, 292) -> (19991, 18342)'

    - 15 missing entries in student solution, including:
      '(11474, 13454) -> (13412, 14842) -> (17288, 17618) -> (18257, 18312)'


    - failed on trial 1 of 50

==> FAILED

Test 9: random line segments
  *  1 random line segment
    - segments() contains a subsegment of a segment in reference solution
    - student   segment 0: (6022, 3732) -> (9648, 5989)
    - reference segment 0: (6022, 3732) -> (8570, 5318) -> (9648, 5989) -> (10824, 6721)

    - number of entries in student   solution: 2
    - number of entries in reference solution: 1
    - 1 extra entry in student solution:
      '(6022, 3732) -> (9648, 5989)'


    - failed on trial 1 of 500
     4
     10824  6721
      9648  5989
      6022  3732
      8570  5318

  *  5 random line segments
    - number of entries in student   solution: 5
    - number of entries in reference solution: 5
    - 4 extra entries in student solution, including:
      '(12208, 1080) -> (4965, 8632)'

    - 4 missing entries in student solution, including:
      '(3777, 7687) -> (4965, 8632) -> (5933, 9402) -> (6285, 9682)'


    - failed on trial 1 of 250
     20
      5933  9402
     11425  4906
     13583  7581
     10931  5007
     11815  5865
     12454  4032
     11182  7007
      4965  8632
      3777  7687
     12382  3168
     11266  7427
     11194  7067
     12232  1368
     12755 13646
      8687  2829
     12741 13554
     11705  6746
     12208  1080
      6285  9682
     11230  7247

  * 10 random line segments
    - segments() contains a subsegment of a segment in reference solution
    - student   segment 2: (3486, 1237) -> (4542, 2197)
    - reference segment 4: (3486, 1237) -> (3662, 1397) -> (4542, 2197) -> (5070, 2677)

    - number of entries in student   solution: 5
    - number of entries in reference solution: 10
    - 5 extra entries in student solution, including:
      '(3486, 1237) -> (5392, 14539)'

    - 10 missing entries in student solution, including:
      '(12876, 12699) -> (13023, 12699) -> (13856, 12699) -> (13905, 12699)'


    - failed on trial 1 of 100

  * 15 random line segments
    - segments() contains a subsegment of a segment in reference solution
    - student   segment 4: (13511, 1295) -> (14412, 5005)
    - reference segment 12: (13511, 1295) -> (14395, 4935) -> (14412, 5005) -> (14463, 5215)

    - number of entries in student   solution: 5
    - number of entries in reference solution: 15
    - 5 extra entries in student solution, including:
      '(13511, 1295) -> (7879, 10736)'

    - 15 missing entries in student solution, including:
      '(839, 11162) -> (1994, 11792) -> (5536, 13724) -> (7461, 14774)'


    - failed on trial 1 of 50

==> FAILED

Test 10: check that data type is immutable by testing whether each method
         returns the same value, regardless of any intervening operations
  * input8.txt
    - failed after 5 operations involving BruteCollinearPoints
    - first and last call to segments() returned different arrays

    - sequence of operations was:
          BruteCollinearPoints collinear = new BruteCollinearPoints(points);
          collinear.segments()
          mutate array returned by last call to segments()
          collinear.numberOfSegments() -> 5
          collinear.segments()

    - failed on trial 1 of 100

  * equidistant.txt
    - failed after 3 operations involving BruteCollinearPoints
    - first and last call to segments() returned different arrays

    - sequence of operations was:
          BruteCollinearPoints collinear = new BruteCollinearPoints(points);
          collinear.segments()
          collinear.segments()

    - failed on trial 1 of 100

==> FAILED

Test 11: check that data type does not mutate the constructor argument
  * input8.txt
  * equidistant.txt
==> passed

Test 12: numberOfSegments() is consistent with segments()
  * filename = input8.txt
  * filename = equidistant.txt
  * filename = input40.txt
  * filename = input48.txt
  * filename = horizontal5.txt
  * filename = vertical5.txt
  * filename = random23.txt
==> passed

Test 13: throws an exception if either the constructor argument is null
         or any entry in array is null
  * argument is null
    - constructor throws wrong exception
    - constructor throws a java.lang.NullPointerException
    - constructor should throw a java.lang.IllegalArgumentException
     0

  * Point[] of length 10, number of null entries = 1
  * Point[] of length 10, number of null entries = 10
  * Point[] of length 4, number of null entries = 1
  * Point[] of length 3, number of null entries = 1
  * Point[] of length 2, number of null entries = 1
    - constructor throws wrong exception
    - constructor throws a java.lang.NullPointerException
    - constructor should throw a java.lang.IllegalArgumentException
     2
     null
     21059  7815

  * Point[] of length 1, number of null entries = 1
    - constructor fails to throw an exception
     1
     null

==> FAILED

Test 14: check that the constructor throws an exception if duplicate points
  * 50 points
  * 25 points
  * 5 points
  * 4 points
  * 3 points
  * 2 points
==> passed


Total: 3/17 tests passed!


================================================================
Testing correctness of FastCollinearPoints
*-----------------------------------------------------------
Running 21 total tests.

The inputs satisfy the following conditions:
  - no duplicate points
  - all x- and y-coordinates between 0 and 32,767

Test 1: points from a file
  * filename = input8.txt
    - segments() contains a subsegment of a segment in reference solution
    - student   segment 0: (0, 10000) -> (3000, 7000)
    - reference segment 0: (10000, 0) -> (7000, 3000) -> (3000, 7000) -> (0, 10000)

    - number of entries in student   solution: 6
    - number of entries in reference solution: 2
    - 6 extra entries in student solution, including:
      '(14000, 15000) -> (6000, 7000)'

    - 2 missing entries in student solution, including:
      '(3000, 4000) -> (6000, 7000) -> (14000, 15000) -> (20000, 21000)'


  * filename = equidistant.txt
    - segments() contains a subsegment of a segment in reference solution
    - student   segment 0: (13000, 0) -> (9000, 6000)
    - reference segment 0: (13000, 0) -> (11000, 3000) -> (9000, 6000) -> (5000, 12000)

    - number of entries in student   solution: 24
    - number of entries in reference solution: 4
    - 23 extra entries in student solution, including:
      '(10000, 20000) -> (0, 30000)'

    - 3 missing entries in student solution, including:
      '(13000, 0) -> (11000, 3000) -> (9000, 6000) -> (5000, 12000)'


  * filename = input40.txt
    - segments() contains a subsegment of a segment in reference solution
    - student   segment 91: (14000, 24000) -> (25000, 24000)
    - reference segment 1: (2000, 24000) -> (9000, 24000) -> (14000, 24000) -> (25000, 24000)

    - number of entries in student   solution: 188
    - number of entries in reference solution: 4
    - 186 extra entries in student solution, including:
      '(1000, 31000) -> (10000, 31000)'

    - 2 missing entries in student solution, including:
      '(1000, 17000) -> (1000, 27000) -> (1000, 28000) -> (1000, 31000)'


  * filename = input48.txt
    - segments() contains a subsegment of a segment in reference solution
    - student   segment 113: (24000, 23000) -> (3000, 23000)
    - reference segment 0: (1000, 23000) -> (3000, 23000) -> (18000, 23000) -> (24000, 23000)

    - number of entries in student   solution: 309
    - number of entries in reference solution: 6
    - 304 extra entries in student solution, including:
      '(24000, 30000) -> (17000, 31000)'

    - 1 missing entry in student solution:
      '(1000, 23000) -> (3000, 23000) -> (18000, 23000) -> (24000, 23000)'


  * filename = input299.txt
    - segments() contains a subsegment of a segment in reference solution
    - student   segment 324: (29900, 1600) -> (21900, 9600)
    - reference segment 0: (31000, 500) -> (29900, 1600) -> (23000, 8500) -> (21900, 9600)

    - number of entries in student   solution: 1700
    - number of entries in reference solution: 6
    - 1694 extra entries in student solution, including:
      '(11800, 32650) -> (1000, 32650)'


==> FAILED

Test 2a: points from a file with horizontal line segments
  * filename = horizontal5.txt
    - segments() contains a subsegment of a segment in reference solution
    - student   segment 1: (2682, 14118) -> (5067, 14118)
    - reference segment 4: (2682, 14118) -> (5067, 14118) -> (7453, 14118) -> (7821, 14118)

    - number of entries in student   solution: 27
    - number of entries in reference solution: 5
    - 22 extra entries in student solution, including:
      '(7821, 14118) -> (5067, 14118)'


  * filename = horizontal25.txt
    - segments() contains a subsegment of a segment in reference solution
    - student   segment 0: (2566, 13870) -> (10653, 13870)
    - reference segment 13: (2566, 13870) -> (10653, 13870) -> (18005, 13870) -> (19459, 13870)

    - number of entries in student   solution: 147
    - number of entries in reference solution: 25
    - 123 extra entries in student solution, including:
      '(16352, 20913) -> (19666, 20913)'

    - 1 missing entry in student solution:
      '(2566, 13870) -> (10653, 13870) -> (18005, 13870) -> (19459, 13870)'


  * filename = horizontal50.txt
    - segments() contains a subsegment of a segment in reference solution
    - student   segment 0: (15233, 7218) -> (17289, 7218)
    - reference segment 17: (6300, 7218) -> (6518, 7218) -> (15233, 7218) -> (17289, 7218)

    - number of entries in student   solution: 297
    - number of entries in reference solution: 50
    - 248 extra entries in student solution, including:
      '(17428, 20754) -> (14800, 20754)'

    - 1 missing entry in student solution:
      '(6300, 7218) -> (6518, 7218) -> (15233, 7218) -> (17289, 7218)'


  * filename = horizontal75.txt
    - segments() contains a subsegment of a segment in reference solution
    - student   segment 1: (3822, 19103) -> (1255, 19103)
    - reference segment 69: (1255, 19103) -> (3822, 19103) -> (8086, 19103) -> (20410, 19103)

    - number of entries in student   solution: 448
    - number of entries in reference solution: 75
    - 374 extra entries in student solution, including:
      '(14591, 20976) -> (14178, 20976)'

    - 1 missing entry in student solution:
      '(1255, 19103) -> (3822, 19103) -> (8086, 19103) -> (20410, 19103)'


  * filename = horizontal100.txt
    - segments() contains a subsegment of a segment in reference solution
    - student   segment 2: (1773, 6140) -> (11759, 6140)
    - reference segment 30: (1238, 6140) -> (1773, 6140) -> (11219, 6140) -> (11759, 6140)

    - number of entries in student   solution: 600
    - number of entries in reference solution: 100
    - 500 extra entries in student solution, including:
      '(19642, 20698) -> (16154, 20698)'


==> FAILED

Test 2b: random horizontal line segments
  *  1 random horizontal line segment
    - segments() contains a subsegment of a segment in reference solution
    - student   segment 0: (14329, 7025) -> (14786, 7025)
    - reference segment 0: (3022, 7025) -> (14329, 7025) -> (14786, 7025) -> (15801, 7025)

    - number of entries in student   solution: 3
    - number of entries in reference solution: 1
    - 3 extra entries in student solution, including:
      '(14786, 7025) -> (15801, 7025)'

    - 1 missing entry in student solution:
      '(3022, 7025) -> (14329, 7025) -> (14786, 7025) -> (15801, 7025)'


    - failed on trial 1 of 500
     4
      3022  7025
     14329  7025
     14786  7025
     15801  7025

  *  5 random horizontal line segments
    - segments() contains a subsegment of a segment in reference solution
    - student   segment 1: (17948, 20106) -> (14943, 20106)
    - reference segment 4: (4946, 20106) -> (7144, 20106) -> (14943, 20106) -> (17948, 20106)

    - number of entries in student   solution: 27
    - number of entries in reference solution: 5
    - 22 extra entries in student solution, including:
      '(17948, 20106) -> (14943, 20106)'


    - failed on trial 1 of 250
     20
      6013  5621
     17948 20106
     13242 17535
      4946 20106
     18371  7256
     19883 17535
     20417  4433
     14932  5621
     19731  7256
     14943 20106
      2022  4433
      9493  5621
     12610 17535
     17646  4433
      3893  7256
      4458  5621
     18258  4433
      7144 20106
      9905 17535
     16489  7256

  * 10 random horizontal line segments
    - segments() contains a subsegment of a segment in reference solution
    - student   segment 0: (3613, 13699) -> (9758, 13699)
    - reference segment 7: (3613, 13699) -> (6620, 13699) -> (9758, 13699) -> (18339, 13699)

    - number of entries in student   solution: 57
    - number of entries in reference solution: 10
    - 48 extra entries in student solution, including:
      '(18491, 15836) -> (20926, 15836)'

    - 1 missing entry in student solution:
      '(12626, 8951) -> (17311, 8951) -> (18080, 8951) -> (18631, 8951)'


    - failed on trial 1 of 50

  * 15 random horizontal line segments
    - segments() contains a subsegment of a segment in reference solution
    - student   segment 1: (4262, 7939) -> (6178, 7939)
    - reference segment 3: (4262, 7939) -> (4338, 7939) -> (6178, 7939) -> (9881, 7939)

    - number of entries in student   solution: 87
    - number of entries in reference solution: 15
    - 73 extra entries in student solution, including:
      '(20034, 20273) -> (19745, 20273)'

    - 1 missing entry in student solution:
      '(2559, 19545) -> (5918, 19545) -> (11248, 19545) -> (15609, 19545)'


    - failed on trial 1 of 5

==> FAILED

Test 3a: points from a file with vertical line segments
  * filename = vertical5.txt
    - segments() contains a subsegment of a segment in reference solution
    - student   segment 0: (14407, 17831) -> (14407, 10367)
    - reference segment 3: (14407, 10367) -> (14407, 17188) -> (14407, 17831) -> (14407, 19953)

    - number of entries in student   solution: 27
    - number of entries in reference solution: 5
    - 23 extra entries in student solution, including:
      '(14407, 17831) -> (14407, 17188)'

    - 1 missing entry in student solution:
      '(14407, 10367) -> (14407, 17188) -> (14407, 17831) -> (14407, 19953)'


  * filename = vertical25.txt
    - segments() contains a subsegment of a segment in reference solution
    - student   segment 0: (11585, 11220) -> (11585, 12912)
    - reference segment 12: (11585, 4132) -> (11585, 5103) -> (11585, 11220) -> (11585, 12912)

    - number of entries in student   solution: 147
    - number of entries in reference solution: 25
    - 122 extra entries in student solution, including:
      '(1825, 19478) -> (1825, 19680)'


  * filename = vertical50.txt
    - segments() contains a subsegment of a segment in reference solution
    - student   segment 0: (10695, 10521) -> (10695, 20927)
    - reference segment 27: (10695, 1287) -> (10695, 10521) -> (10695, 20756) -> (10695, 20927)

    - number of entries in student   solution: 297
    - number of entries in reference solution: 50
    - 247 extra entries in student solution, including:
      '(5991, 20340) -> (5991, 20424)'


  * filename = vertical75.txt
    - segments() contains a subsegment of a segment in reference solution
    - student   segment 1: (2329, 3548) -> (2329, 5466)
    - reference segment 2: (2329, 3548) -> (2329, 5466) -> (2329, 9995) -> (2329, 11424)

    - number of entries in student   solution: 447
    - number of entries in reference solution: 75
    - 372 extra entries in student solution, including:
      '(6614, 20700) -> (6614, 20468)'


  * filename = vertical100.txt
    - segments() contains a subsegment of a segment in reference solution
    - student   segment 4: (6177, 10008) -> (6177, 15031)
    - reference segment 26: (6177, 7115) -> (6177, 10008) -> (6177, 15031) -> (6177, 18079)

    - number of entries in student   solution: 601
    - number of entries in reference solution: 100
    - 502 extra entries in student solution, including:
      '(17852, 20904) -> (17852, 20150)'

    - 1 missing entry in student solution:
      '(6177, 7115) -> (6177, 10008) -> (6177, 15031) -> (6177, 18079)'


==> FAILED

Test 3b: random vertical line segments
  *  1 random vertical line segment
    - segments() contains a subsegment of a segment in reference solution
    - student   segment 1: (10585, 11974) -> (10585, 5960)
    - reference segment 0: (10585, 5006) -> (10585, 5960) -> (10585, 11296) -> (10585, 11974)

    - number of entries in student   solution: 3
    - number of entries in reference solution: 1
    - 2 extra entries in student solution, including:
      '(10585, 11974) -> (10585, 5960)'


    - failed on trial 1 of 500
     4
     10585 11296
     10585 11974
     10585  5006
     10585  5960

  *  5 random vertical line segments
    - segments() contains a subsegment of a segment in reference solution
    - student   segment 0: (7271, 8195) -> (7271, 11501)
    - reference segment 1: (7271, 8195) -> (7271, 8798) -> (7271, 11501) -> (7271, 20037)

    - number of entries in student   solution: 27
    - number of entries in reference solution: 5
    - 22 extra entries in student solution, including:
      '(7693, 20261) -> (7693, 20462)'


    - failed on trial 1 of 250
     20
      7693 15100
      7271  8195
      9107 10889
      9107  2591
      1383 15793
     17661 20977
      9107 12468
      1383  7693
     17661 18710
      7271 11501
      1383 16437
      7693  2143
      7693 20261
      7271 20037
     17661 19002
      7271  8798
      7693 20462
     17661 14234
      1383  9579
      9107  9290

  * 10 random vertical line segments
    - segments() contains a subsegment of a segment in reference solution
    - student   segment 0: (3069, 13915) -> (3069, 7119)
    - reference segment 0: (3069, 1208) -> (3069, 2562) -> (3069, 7119) -> (3069, 13915)

    - number of entries in student   solution: 57
    - number of entries in reference solution: 10
    - 48 extra entries in student solution, including:
      '(14051, 20264) -> (14051, 19118)'

    - 1 missing entry in student solution:
      '(10896, 2048) -> (10896, 6656) -> (10896, 13769) -> (10896, 15879)'


    - failed on trial 1 of 50

  * 15 random vertical line segments
    - segments() contains a subsegment of a segment in reference solution
    - student   segment 0: (15227, 16777) -> (15227, 2413)
    - reference segment 9: (15227, 2413) -> (15227, 12212) -> (15227, 16777) -> (15227, 18909)

    - number of entries in student   solution: 87
    - number of entries in reference solution: 15
    - 73 extra entries in student solution, including:
      '(17845, 20635) -> (17845, 20476)'

    - 1 missing entry in student solution:
      '(8835, 6396) -> (8835, 7502) -> (8835, 17225) -> (8835, 20449)'


    - failed on trial 1 of 5

==> FAILED

Test 4a: points from a file with no line segments
  * filename = random23.txt
  * filename = random38.txt
  * filename = random91.txt
  * filename = random152.txt
==> passed

Test 4b: random points with no line segments
  *  5 random points
  * 10 random points
  * 20 random points
  * 50 random points
==> passed

Test 5a: points from a file with 5 or more on some line segments
  * filename = input9.txt
    - segments() contains a subsegment of a segment in reference solution
    - student   segment 0: (9000, 9000) -> (5000, 5000)
    - reference segment 0: (1000, 1000) -> (2000, 2000) -> (3000, 3000) -> (4000, 4000) -> (5000, 5000) -> (6000, 6000) -> (7000, 7000) -> (8000, 8000) -> (9000, 9000)

    - number of entries in student   solution: 33
    - number of entries in reference solution: 1
    - 32 extra entries in student solution, including:
      '(8000, 8000) -> (7000, 7000)'


  * filename = input10.txt
    - segments() contains a subsegment of a segment in reference solution
    - student   segment 0: (13000, 21000) -> (23000, 16000)
    - reference segment 0: (28000, 13500) -> (23000, 16000) -> (13000, 21000) -> (3000, 26000)

    - number of entries in student   solution: 10
    - number of entries in reference solution: 2
    - 9 extra entries in student solution, including:
      '(3500, 28000) -> (3000, 26000)'

    - 1 missing entry in student solution:
      '(28000, 13500) -> (23000, 16000) -> (13000, 21000) -> (3000, 26000)'


  * filename = input20.txt
    - segments() contains a subsegment of a segment in reference solution
    - student   segment 9: (5120, 20992) -> (6144, 20992)
    - reference segment 0: (4096, 20992) -> (5120, 20992) -> (6144, 20992) -> (7168, 20992) -> (8128, 20992)

    - number of entries in student   solution: 78
    - number of entries in reference solution: 5
    - 73 extra entries in student solution, including:
      '(8192, 29184) -> (7168, 29184)'


  * filename = input50.txt
    - segments() contains a subsegment of a segment in reference solution
    - student   segment 123: (24000, 23000) -> (3000, 23000)
    - reference segment 0: (1000, 23000) -> (3000, 23000) -> (18000, 23000) -> (24000, 23000)

    - number of entries in student   solution: 352
    - number of entries in reference solution: 7
    - 346 extra entries in student solution, including:
      '(24000, 30000) -> (17000, 31000)'

    - 1 missing entry in student solution:
      '(1000, 23000) -> (3000, 23000) -> (18000, 23000) -> (24000, 23000)'


  * filename = input80.txt
    - segments() contains a subsegment of a segment in reference solution
    - student   segment 124: (31000, 1000) -> (24000, 22000)
    - reference segment 0: (31000, 1000) -> (26000, 16000) -> (24000, 22000) -> (22000, 28000)

    - number of entries in student   solution: 1494
    - number of entries in reference solution: 31
    - 1464 extra entries in student solution, including:
      '(27000, 31000) -> (29000, 31000)'

    - 1 missing entry in student solution:
      '(0, 23000) -> (8000, 23000) -> (21000, 23000) -> (26000, 23000) -> (30000, 23000)'


  * filename = input300.txt
    - segments() contains a subsegment of a segment in reference solution
    - student   segment 332: (29900, 1600) -> (21900, 9600)
    - reference segment 0: (31000, 500) -> (29900, 1600) -> (23000, 8500) -> (21900, 9600)

    - number of entries in student   solution: 1730
    - number of entries in reference solution: 6
    - 1724 extra entries in student solution, including:
      '(11800, 32650) -> (1000, 32650)'


  * filename = inarow.txt
    - segments() contains a subsegment of a segment in reference solution
    - student   segment 0: (30000, 0) -> (20000, 25000)
    - reference segment 0: (30000, 0) -> (27000, 7500) -> (26000, 10000) -> (20000, 25000) -> (19000, 27500) -> (18000, 30000)

    - number of entries in student   solution: 79
    - number of entries in reference solution: 5
    - 75 extra entries in student solution, including:
      '(18000, 30000) -> (0, 30000)'

    - 1 missing entry in student solution:
      '(0, 0) -> (2300, 4100) -> (4600, 8200) -> (11500, 20500)'


==> FAILED

Test 5b: points from a file with 5 or more on some line segments
  * filename = kw1260.txt
    - segments() contains a subsegment of a segment in reference solution
    - student   segment 20: (22440, 16455) -> (22335, 19149)
    - reference segment 0: (22440, 16455) -> (22405, 17353) -> (22370, 18251) -> (22335, 19149) -> (22300, 20047)

    - number of entries in student   solution: 6753
    - number of entries in reference solution: 288
    - 6589 extra entries in student solution, including:
      '(14764, 30467) -> (14236, 30449)'

    - 124 missing entries in student solution, including:
      '(12652, 30395) -> (13180, 30413) -> (13708, 30431) -> (14236, 30449) -> (14764, 30467)'


  * filename = rs1423.txt
    - segments() contains a subsegment of a segment in reference solution
    - student   segment 0: (3995, 9017) -> (3994, 9820)
    - reference segment 0: (3996, 8214) -> (3995, 9017) -> (3994, 9820) -> (3993, 10623)

    - number of entries in student   solution: 4864
    - number of entries in reference solution: 443
    - 4710 extra entries in student solution, including:
      '(13053, 28029) -> (13443, 28086)'

    - 289 missing entries in student solution, including:
      '(14169, 27672) -> (13927, 27810) -> (13685, 27948) -> (13443, 28086)'


==> FAILED

Test 6: points from a file with fewer than 4 points
  * filename = input1.txt
  * filename = input2.txt
  * filename = input3.txt
==> passed

Test 7: check for dependence on either compareTo() or compare()
        returning { -1, +1, 0 } instead of { negative integer,
        positive integer, zero }
  * filename = equidistant.txt
    - segments() contains a subsegment of a segment in reference solution
    - student   segment 0: (13000, 0) -> (9000, 6000)
    - reference segment 0: (13000, 0) -> (11000, 3000) -> (9000, 6000) -> (5000, 12000)

    - number of entries in student   solution: 24
    - number of entries in reference solution: 4
    - 23 extra entries in student solution, including:
      '(10000, 20000) -> (0, 30000)'

    - 3 missing entries in student solution, including:
      '(13000, 0) -> (11000, 3000) -> (9000, 6000) -> (5000, 12000)'


  * filename = input40.txt
    - segments() contains a subsegment of a segment in reference solution
    - student   segment 91: (14000, 24000) -> (25000, 24000)
    - reference segment 1: (2000, 24000) -> (9000, 24000) -> (14000, 24000) -> (25000, 24000)

    - number of entries in student   solution: 188
    - number of entries in reference solution: 4
    - 186 extra entries in student solution, including:
      '(1000, 31000) -> (10000, 31000)'

    - 2 missing entries in student solution, including:
      '(1000, 17000) -> (1000, 27000) -> (1000, 28000) -> (1000, 31000)'


  * filename = input48.txt
    - segments() contains a subsegment of a segment in reference solution
    - student   segment 113: (24000, 23000) -> (3000, 23000)
    - reference segment 0: (1000, 23000) -> (3000, 23000) -> (18000, 23000) -> (24000, 23000)

    - number of entries in student   solution: 309
    - number of entries in reference solution: 6
    - 304 extra entries in student solution, including:
      '(24000, 30000) -> (17000, 31000)'

    - 1 missing entry in student solution:
      '(1000, 23000) -> (3000, 23000) -> (18000, 23000) -> (24000, 23000)'


  * filename = input299.txt
    - segments() contains a subsegment of a segment in reference solution
    - student   segment 324: (29900, 1600) -> (21900, 9600)
    - reference segment 0: (31000, 500) -> (29900, 1600) -> (23000, 8500) -> (21900, 9600)

    - number of entries in student   solution: 1700
    - number of entries in reference solution: 6
    - 1694 extra entries in student solution, including:
      '(11800, 32650) -> (1000, 32650)'


==> FAILED

Test 8: check for fragile dependence on return value of toString()
  * filename = equidistant.txt
    - segments() contains a subsegment of a segment in reference solution
    - student   segment 0: (13000, 0) -> (9000, 6000)
    - reference segment 0: (13000, 0) -> (11000, 3000) -> (9000, 6000) -> (5000, 12000)

    - number of entries in student   solution: 24
    - number of entries in reference solution: 4
    - 23 extra entries in student solution, including:
      '(10000, 20000) -> (0, 30000)'

    - 3 missing entries in student solution, including:
      '(13000, 0) -> (11000, 3000) -> (9000, 6000) -> (5000, 12000)'


  * filename = input40.txt
    - segments() contains a subsegment of a segment in reference solution
    - student   segment 91: (14000, 24000) -> (25000, 24000)
    - reference segment 1: (2000, 24000) -> (9000, 24000) -> (14000, 24000) -> (25000, 24000)

    - number of entries in student   solution: 188
    - number of entries in reference solution: 4
    - 186 extra entries in student solution, including:
      '(1000, 31000) -> (10000, 31000)'

    - 2 missing entries in student solution, including:
      '(1000, 17000) -> (1000, 27000) -> (1000, 28000) -> (

...

WARNING: the grading output was truncated due to excessive length.
Typically, this is because you have a method that has an unanticipated side effect
(such as printing to standard output or throwing an exception). A large amount of output
can also arise from failing many tests.
