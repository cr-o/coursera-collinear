See the Assessment Guide for information on how to interpret this report.

ASSESSMENT SUMMARY

Compilation:  PASSED
API:          PASSED

Spotbugs:     FAILED (15 warnings)
PMD:          FAILED (10 warnings)
Checkstyle:   FAILED (0 errors, 1 warning)

Correctness:  12/41 tests passed
Memory:       1/1 tests passed
Timing:       0/41 tests passed

Aggregate score: 37.56%
[Compilation: 5%, API: 5%, Spotbugs: 0%, PMD: 0%, Checkstyle: 0%, Correctness: 60%, Memory: 10%, Timing: 20%]

ASSESSMENT DETAILS

The following files were submitted:
----------------------------------
5.2K Jan  6 15:37 BruteCollinearPoints.java
8.6K Jan  6 15:37 FastCollinearPoints.java
4.3K Jan  6 15:37 Point.java


********************************************************************************
*  COMPILING
********************************************************************************


% javac11 Point.java
*-----------------------------------------------------------

% javac11 LineSegment.java
*-----------------------------------------------------------

% javac11 BruteCollinearPoints.java
*-----------------------------------------------------------

% javac11 FastCollinearPoints.java
*-----------------------------------------------------------


================================================================


Checking the APIs of your programs.
*-----------------------------------------------------------
Point:

BruteCollinearPoints:

FastCollinearPoints:

================================================================


********************************************************************************
*  CHECKING STYLE AND COMMON BUG PATTERNS
********************************************************************************


% spotbugs *.class
*-----------------------------------------------------------
M D UC_USELESS_OBJECT UC: The object stored in the variable 'pt' is created and modified, but its value never goes outside of the method 'main()' or produces any side effect.  At Point.java:[line 133]
M D UC_USELESS_OBJECT UC: The object stored in the variable 'pt2' is created and modified, but its value never goes outside of the method 'main()' or produces any side effect.  At Point.java:[line 134]
M D DLS_DEAD_LOCAL_STORE DLS: Assigns a value to the local variable 'slopeResult' but that value is never used.  At Point.java:[line 136]
M D DLS_DEAD_LOCAL_STORE DLS: Assigns a value to the local variable 'comparator' but that value is never used.  At Point.java:[line 137]
M D DLS_DEAD_LOCAL_STORE DLS: Assigns a value to the local variable 'compareResult' but that value is never used.  At Point.java:[line 135]
L D FE_FLOATING_POINT_EQUALITY FE: Tests for exact floating-point equality. Because floating-point calculations may involve rounding, the calculated values may be imprecise.  At Point.java:[line 68]
H D UC_USELESS_VOID_METHOD UC: The void method 'main()' appears to serve no purpose.  At Point.java:[line 139]
M C SUA_SUSPICIOUS_UNINITIALIZED_ARRAY SUA: Method BruteCollinearPoints.segments() returns an array that appears not to be initialized  At BruteCollinearPoints.java:[line 86]
M V EI_EXPOSE_REP2 EI2: Stores a reference to an externally mutable object in the instance variable 'points', exposing the internal representation of the class 'BruteCollinearPoints'. Instead, create a defensive copy of the object referenced by the parameter variable 'points' and store that copy in the instance variable 'points'.  At BruteCollinearPoints.java:[line 23]
L D FE_FLOATING_POINT_EQUALITY FE: Tests for exact floating-point equality. Because floating-point calculations may involve rounding, the calculated values may be imprecise.  At BruteCollinearPoints.java:[line 57]
M V EI_EXPOSE_REP2 EI2: Stores a reference to an externally mutable object in the instance variable 'points', exposing the internal representation of the class 'FastCollinearPoints'. Instead, create a defensive copy of the object referenced by the parameter variable 'points' and store that copy in the instance variable 'points'.  At FastCollinearPoints.java:[line 23]
L D FE_FLOATING_POINT_EQUALITY FE: Tests for exact floating-point equality. Because floating-point calculations may involve rounding, the calculated values may be imprecise.  At FastCollinearPoints.java:[line 86]
L P SIC_INNER_SHOULD_BE_STATIC_ANON SIC: Should the anonymous inner class 'BruteCollinearPoints$1' be refactored into a named static nested class?  At BruteCollinearPoints.java:[line 91]
L P SIC_INNER_SHOULD_BE_STATIC_ANON SIC: Should the anonymous inner class 'FastCollinearPoints$1' be refactored into a named static nested class?  At FastCollinearPoints.java:[line 170]
L P SIC_INNER_SHOULD_BE_STATIC_ANON SIC: Should the anonymous inner class 'FastCollinearPoints$2' be refactored into a named static nested class?  At FastCollinearPoints.java:[line 178]
Warnings generated: 15


================================================================


% pmd .
*-----------------------------------------------------------
BruteCollinearPoints.java:17: The private instance (or static) variable 'points' can be made 'final'; it is initialized only in the declaration or constructor. [ImmutableField]
BruteCollinearPoints.java:19: The user-supplied array 'points' is stored directly. [ArrayIsStoredDirectly]
FastCollinearPoints.java:17: The private instance (or static) variable 'points' can be made 'final'; it is initialized only in the declaration or constructor. [ImmutableField]
FastCollinearPoints.java:19: The user-supplied array 'points' is stored directly. [ArrayIsStoredDirectly]
FastCollinearPoints.java:42: The private instance (or static) variable 'origin' can be made 'final'; it is initialized only in the declaration or constructor. [ImmutableField]
FastCollinearPoints.java:43: The private instance (or static) variable 'point' can be made 'final'; it is initialized only in the declaration or constructor. [ImmutableField]
FastCollinearPoints.java:44: The private instance (or static) variable 'slopeToOrigin' can be made 'final'; it is initialized only in the declaration or constructor. [ImmutableField]
Point.java:135: Avoid unused local variables, such as 'compareResult'. [UnusedLocalVariable]
Point.java:136: Avoid unused local variables, such as 'slopeResult'. [UnusedLocalVariable]
Point.java:137: Avoid unused local variables, such as 'comparator'. [UnusedLocalVariable]
PMD ends with 10 warnings.


================================================================


% checkstyle *.java
*-----------------------------------------------------------

% custom checkstyle checks for Point.java
*-----------------------------------------------------------

% custom checkstyle checks for BruteCollinearPoints.java
*-----------------------------------------------------------

% custom checkstyle checks for FastCollinearPoints.java
*-----------------------------------------------------------
[WARN] FastCollinearPoints.java:15:1: Defining a nested class in this program suggests poor design. [Design]
Checkstyle ends with 0 errors and 1 warning.


================================================================


********************************************************************************
*  TESTING CORRECTNESS
********************************************************************************

Testing correctness of Point
*-----------------------------------------------------------
Running 3 total tests.

Test 1: p.slopeTo(q)
  * positive infinite slope, where p and q have coordinates in [0, 500)
  * positive infinite slope, where p and q have coordinates in [0, 32768)
  * negative infinite slope, where p and q have coordinates in [0, 500)
  * negative infinite slope, where p and q have coordinates in [0, 32768)
  * positive zero     slope, where p and q have coordinates in [0, 500)
  * positive zero     slope, where p and q have coordinates in [0, 32768)
  * symmetric for random points p and q with coordinates in [0, 500)
  * symmetric for random points p and q with coordinates in [0, 32768)
  * transitive for random points p, q, and r with coordinates in [0, 500)
  * transitive for random points p, q, and r with coordinates in [0, 32768)
  * slopeTo(), where p and q have coordinates in [0, 500)
  * slopeTo(), where p and q have coordinates in [0, 32768)
  * slopeTo(), where p and q have coordinates in [0, 10)
  * throw a java.lang.NullPointerException if argument is null
==> passed

Test 2: p.compareTo(q)
  * reflexive, where p and q have coordinates in [0, 500)
  * reflexive, where p and q have coordinates in [0, 32768)
  * antisymmetric, where p and q have coordinates in [0, 500)
  * antisymmetric, where p and q have coordinates in [0, 32768)
  * transitive, where p, q, and r have coordinates in [0, 500)
  * transitive, where p, q, and r have coordinates in [0, 32768)
  * sign of compareTo(), where p and q have coordinates in [0, 500)
  * sign of compareTo(), where p and q have coordinates in [0, 32768)
  * sign of compareTo(), where p and q have coordinates in [0, 10)
  * throw java.lang.NullPointerException exception if argument is null
==> passed

Test 3: p.slopeOrder().compare(q, r)
  * reflexive, where p and q have coordinates in [0, 500)
  * reflexive, where p and q have coordinates in [0, 32768)
  * antisymmetric, where p, q, and r have coordinates in [0, 500)
  * antisymmetric, where p, q, and r have coordinates in [0, 32768)
  * transitive, where p, q, r, and s have coordinates in [0, 500)
  * transitive, where p, q, r, and s have coordinates in [0, 32768)
  * sign of compare(), where p, q, and r have coordinates in [0, 500)
  * sign of compare(), where p, q, and r have coordinates in [0, 32768)
  * sign of compare(), where p, q, and r have coordinates in [0, 10)
  * throw java.lang.NullPointerException if either argument is null
==> passed


Total: 3/3 tests passed!


================================================================
********************************************************************************
*  TESTING CORRECTNESS (substituting reference Point and LineSegment)
********************************************************************************

Testing correctness of BruteCollinearPoints
*-----------------------------------------------------------
Running 17 total tests.

The inputs satisfy the following conditions:
  - no duplicate points
  - no 5 (or more) points are collinear
  - all x- and y-coordinates between 0 and 32,767

Test 1: points from a file
  * filename = input8.txt

    java.lang.NullPointerException: segment 0 is null

    TestBruteCollinearPoints.toLineSegments226(TestBruteCollinearPoints.java:48)
    TestBruteCollinearPoints.testSegments(TestBruteCollinearPoints.java:109)
    TestBruteCollinearPoints.file(TestBruteCollinearPoints.java:150)
    TestBruteCollinearPoints.test1(TestBruteCollinearPoints.java:155)
    TestBruteCollinearPoints.main(TestBruteCollinearPoints.java:717)

  * filename = equidistant.txt

    java.lang.NullPointerException: segment 0 is null

    TestBruteCollinearPoints.toLineSegments226(TestBruteCollinearPoints.java:48)
    TestBruteCollinearPoints.testSegments(TestBruteCollinearPoints.java:109)
    TestBruteCollinearPoints.file(TestBruteCollinearPoints.java:150)
    TestBruteCollinearPoints.test1(TestBruteCollinearPoints.java:156)
    TestBruteCollinearPoints.main(TestBruteCollinearPoints.java:717)

  * filename = input40.txt

    java.lang.NullPointerException: segment 0 is null

    TestBruteCollinearPoints.toLineSegments226(TestBruteCollinearPoints.java:48)
    TestBruteCollinearPoints.testSegments(TestBruteCollinearPoints.java:109)
    TestBruteCollinearPoints.file(TestBruteCollinearPoints.java:150)
    TestBruteCollinearPoints.test1(TestBruteCollinearPoints.java:157)
    TestBruteCollinearPoints.main(TestBruteCollinearPoints.java:717)

  * filename = input48.txt

    java.lang.NullPointerException: segment 0 is null

    TestBruteCollinearPoints.toLineSegments226(TestBruteCollinearPoints.java:48)
    TestBruteCollinearPoints.testSegments(TestBruteCollinearPoints.java:109)
    TestBruteCollinearPoints.file(TestBruteCollinearPoints.java:150)
    TestBruteCollinearPoints.test1(TestBruteCollinearPoints.java:158)
    TestBruteCollinearPoints.main(TestBruteCollinearPoints.java:717)

==> FAILED

Test 2a: points from a file with horizontal line segments
  * filename = horizontal5.txt

    java.lang.NullPointerException: segment 0 is null

    TestBruteCollinearPoints.toLineSegments226(TestBruteCollinearPoints.java:48)
    TestBruteCollinearPoints.testSegments(TestBruteCollinearPoints.java:109)
    TestBruteCollinearPoints.file(TestBruteCollinearPoints.java:150)
    TestBruteCollinearPoints.test2a(TestBruteCollinearPoints.java:164)
    TestBruteCollinearPoints.main(TestBruteCollinearPoints.java:720)

  * filename = horizontal25.txt

    java.lang.NullPointerException: segment 0 is null

    TestBruteCollinearPoints.toLineSegments226(TestBruteCollinearPoints.java:48)
    TestBruteCollinearPoints.testSegments(TestBruteCollinearPoints.java:109)
    TestBruteCollinearPoints.file(TestBruteCollinearPoints.java:150)
    TestBruteCollinearPoints.test2a(TestBruteCollinearPoints.java:165)
    TestBruteCollinearPoints.main(TestBruteCollinearPoints.java:720)

==> FAILED

Test 2b: random horizontal line segments
  *  1 random horizontal line segment
  *  5 random horizontal line segments

    java.lang.NullPointerException: segment 0 is null

    TestBruteCollinearPoints.toLineSegments226(TestBruteCollinearPoints.java:48)
    TestBruteCollinearPoints.testSegments(TestBruteCollinearPoints.java:109)
    TestBruteCollinearPoints.horizontalSegments(TestBruteCollinearPoints.java:177)
    TestBruteCollinearPoints.test2b(TestBruteCollinearPoints.java:220)
    TestBruteCollinearPoints.main(TestBruteCollinearPoints.java:723)

    - failed on trial 1 of 250
     20
      5779 17377
      8919  2679
     14736  2679
     16682  3567
     20230  3567
     11730  4604
     13541  4604
     20762 17377
      3454 17377
     20818  4604
     20534  3567
      9742  2679
     14290  2679
     18045  4604
     16867 18839
     12326 17377
     18856 18839
     12988 18839
     18456 18839
      1942  3567

  * 10 random horizontal line segments

    java.lang.NullPointerException: segment 0 is null

    TestBruteCollinearPoints.toLineSegments226(TestBruteCollinearPoints.java:48)
    TestBruteCollinearPoints.testSegments(TestBruteCollinearPoints.java:109)
    TestBruteCollinearPoints.horizontalSegments(TestBruteCollinearPoints.java:177)
    TestBruteCollinearPoints.test2b(TestBruteCollinearPoints.java:221)
    TestBruteCollinearPoints.main(TestBruteCollinearPoints.java:723)

    - failed on trial 1 of 50

  * 15 random horizontal line segments

    java.lang.NullPointerException: segment 0 is null

    TestBruteCollinearPoints.toLineSegments226(TestBruteCollinearPoints.java:48)
    TestBruteCollinearPoints.testSegments(TestBruteCollinearPoints.java:109)
    TestBruteCollinearPoints.horizontalSegments(TestBruteCollinearPoints.java:177)
    TestBruteCollinearPoints.test2b(TestBruteCollinearPoints.java:222)
    TestBruteCollinearPoints.main(TestBruteCollinearPoints.java:723)

    - failed on trial 1 of 5

==> FAILED

Test 3a: points from a file with vertical line segments
  * filename = vertical5.txt

    java.lang.NullPointerException: segment 0 is null

    TestBruteCollinearPoints.toLineSegments226(TestBruteCollinearPoints.java:48)
    TestBruteCollinearPoints.testSegments(TestBruteCollinearPoints.java:109)
    TestBruteCollinearPoints.file(TestBruteCollinearPoints.java:150)
    TestBruteCollinearPoints.test3a(TestBruteCollinearPoints.java:228)
    TestBruteCollinearPoints.main(TestBruteCollinearPoints.java:726)

  * filename = vertical25.txt

    java.lang.NullPointerException: segment 0 is null

    TestBruteCollinearPoints.toLineSegments226(TestBruteCollinearPoints.java:48)
    TestBruteCollinearPoints.testSegments(TestBruteCollinearPoints.java:109)
    TestBruteCollinearPoints.file(TestBruteCollinearPoints.java:150)
    TestBruteCollinearPoints.test3a(TestBruteCollinearPoints.java:229)
    TestBruteCollinearPoints.main(TestBruteCollinearPoints.java:726)

==> FAILED

Test 3b: random vertical line segments
  *  1 random vertical line segment
  *  5 random vertical line segments

    java.lang.NullPointerException: segment 0 is null

    TestBruteCollinearPoints.toLineSegments226(TestBruteCollinearPoints.java:48)
    TestBruteCollinearPoints.testSegments(TestBruteCollinearPoints.java:109)
    TestBruteCollinearPoints.verticalSegments(TestBruteCollinearPoints.java:201)
    TestBruteCollinearPoints.test3b(TestBruteCollinearPoints.java:236)
    TestBruteCollinearPoints.main(TestBruteCollinearPoints.java:729)

    - failed on trial 1 of 250
     20
      9686  6251
     15731  2610
      9147 14935
      9147 12524
      9686 18283
     15731 12556
      8505  8228
      8505  3477
      9686  9572
      9147 19980
      8505  1529
     12896 17262
     15731 16655
     15731  2158
      8505 20228
     12896  1130
     12896  2568
     12896 10893
      9147 13642
      9686  9857

  * 10 random vertical line segments

    java.lang.NullPointerException: segment 0 is null

    TestBruteCollinearPoints.toLineSegments226(TestBruteCollinearPoints.java:48)
    TestBruteCollinearPoints.testSegments(TestBruteCollinearPoints.java:109)
    TestBruteCollinearPoints.verticalSegments(TestBruteCollinearPoints.java:201)
    TestBruteCollinearPoints.test3b(TestBruteCollinearPoints.java:237)
    TestBruteCollinearPoints.main(TestBruteCollinearPoints.java:729)

    - failed on trial 1 of 50

  * 15 random vertical line segments

    java.lang.NullPointerException: segment 0 is null

    TestBruteCollinearPoints.toLineSegments226(TestBruteCollinearPoints.java:48)
    TestBruteCollinearPoints.testSegments(TestBruteCollinearPoints.java:109)
    TestBruteCollinearPoints.verticalSegments(TestBruteCollinearPoints.java:201)
    TestBruteCollinearPoints.test3b(TestBruteCollinearPoints.java:238)
    TestBruteCollinearPoints.main(TestBruteCollinearPoints.java:729)

    - failed on trial 1 of 5

==> FAILED

Test 4a: points from a file with no line segments
  * filename = random23.txt

    java.lang.NullPointerException: segment 0 is null

    TestBruteCollinearPoints.toLineSegments226(TestBruteCollinearPoints.java:48)
    TestBruteCollinearPoints.testSegments(TestBruteCollinearPoints.java:109)
    TestBruteCollinearPoints.file(TestBruteCollinearPoints.java:150)
    TestBruteCollinearPoints.test4a(TestBruteCollinearPoints.java:244)
    TestBruteCollinearPoints.main(TestBruteCollinearPoints.java:732)

  * filename = random38.txt

    java.lang.NullPointerException: segment 0 is null

    TestBruteCollinearPoints.toLineSegments226(TestBruteCollinearPoints.java:48)
    TestBruteCollinearPoints.testSegments(TestBruteCollinearPoints.java:109)
    TestBruteCollinearPoints.file(TestBruteCollinearPoints.java:150)
    TestBruteCollinearPoints.test4a(TestBruteCollinearPoints.java:245)
    TestBruteCollinearPoints.main(TestBruteCollinearPoints.java:732)

==> FAILED

Test 4b: random points with no line segments
  *  5 random points

    java.lang.NullPointerException: segment 0 is null

    TestBruteCollinearPoints.toLineSegments226(TestBruteCollinearPoints.java:48)
    TestBruteCollinearPoints.testSegments(TestBruteCollinearPoints.java:109)
    TestBruteCollinearPoints.no4CollinearPoints(TestBruteCollinearPoints.java:256)
    TestBruteCollinearPoints.test4b(TestBruteCollinearPoints.java:274)
    TestBruteCollinearPoints.main(TestBruteCollinearPoints.java:735)

    - failed on trial 1 of 500
     5
     11076 10563
     20891 20163
     11935 21785
     30521 20635
      9403 20151

  * 10 random points

    java.lang.NullPointerException: segment 0 is null

    TestBruteCollinearPoints.toLineSegments226(TestBruteCollinearPoints.java:48)
    TestBruteCollinearPoints.testSegments(TestBruteCollinearPoints.java:109)
    TestBruteCollinearPoints.no4CollinearPoints(TestBruteCollinearPoints.java:256)
    TestBruteCollinearPoints.test4b(TestBruteCollinearPoints.java:275)
    TestBruteCollinearPoints.main(TestBruteCollinearPoints.java:735)

    - failed on trial 1 of 250
     10
      2049 29210
     22055  7353
      8372 24113
      6067 24484
      7322   199
     22996  4533
     26449 29045
     11805 24176
     26290 16946
     26958  8525

  * 20 random points

    java.lang.NullPointerException: segment 0 is null

    TestBruteCollinearPoints.toLineSegments226(TestBruteCollinearPoints.java:48)
    TestBruteCollinearPoints.testSegments(TestBruteCollinearPoints.java:109)
    TestBruteCollinearPoints.no4CollinearPoints(TestBruteCollinearPoints.java:256)
    TestBruteCollinearPoints.test4b(TestBruteCollinearPoints.java:276)
    TestBruteCollinearPoints.main(TestBruteCollinearPoints.java:735)

    - failed on trial 1 of 100
     20
     11103 22813
     18908 28127
     22972 22947
       658 20514
     10799 11417
     10189  2808
     23030 32754
      6060 17166
     29198  9168
     26721 26207
      5170 13212
     29585  9970
     12518 12571
      3403 18895
     17701  7564
      4333 26848
      8751 23528
     14054  2002
     13336 17657
     12847  8165

  * 50 random points

    java.lang.NullPointerException: segment 0 is null

    TestBruteCollinearPoints.toLineSegments226(TestBruteCollinearPoints.java:48)
    TestBruteCollinearPoints.testSegments(TestBruteCollinearPoints.java:109)
    TestBruteCollinearPoints.no4CollinearPoints(TestBruteCollinearPoints.java:256)
    TestBruteCollinearPoints.test4b(TestBruteCollinearPoints.java:277)
    TestBruteCollinearPoints.main(TestBruteCollinearPoints.java:735)

    - failed on trial 1 of 10

==> FAILED

Test 5: points from a file with fewer than 4 points
  * filename = input1.txt

    java.lang.NullPointerException: segment 0 is null

    TestBruteCollinearPoints.toLineSegments226(TestBruteCollinearPoints.java:48)
    TestBruteCollinearPoints.testSegments(TestBruteCollinearPoints.java:109)
    TestBruteCollinearPoints.file(TestBruteCollinearPoints.java:150)
    TestBruteCollinearPoints.test5(TestBruteCollinearPoints.java:283)
    TestBruteCollinearPoints.main(TestBruteCollinearPoints.java:738)

  * filename = input2.txt

    java.lang.NullPointerException: segment 0 is null

    TestBruteCollinearPoints.toLineSegments226(TestBruteCollinearPoints.java:48)
    TestBruteCollinearPoints.testSegments(TestBruteCollinearPoints.java:109)
    TestBruteCollinearPoints.file(TestBruteCollinearPoints.java:150)
    TestBruteCollinearPoints.test5(TestBruteCollinearPoints.java:284)
    TestBruteCollinearPoints.main(TestBruteCollinearPoints.java:738)

  * filename = input3.txt

    java.lang.NullPointerException: segment 0 is null

    TestBruteCollinearPoints.toLineSegments226(TestBruteCollinearPoints.java:48)
    TestBruteCollinearPoints.testSegments(TestBruteCollinearPoints.java:109)
    TestBruteCollinearPoints.file(TestBruteCollinearPoints.java:150)
    TestBruteCollinearPoints.test5(TestBruteCollinearPoints.java:285)
    TestBruteCollinearPoints.main(TestBruteCollinearPoints.java:738)

==> FAILED

Test 6: check for dependence on either compareTo() or compare()
        returning { -1, +1, 0 } instead of { negative integer,
        positive integer, zero }
  * filename = equidistant.txt

    java.lang.NullPointerException: segment 0 is null

    TestBruteCollinearPoints.toLineSegments226(TestBruteCollinearPoints.java:48)
    TestBruteCollinearPoints.testSegments(TestBruteCollinearPoints.java:109)
    TestBruteCollinearPoints.file(TestBruteCollinearPoints.java:150)
    TestBruteCollinearPoints.test6(TestBruteCollinearPoints.java:294)
    TestBruteCollinearPoints.main(TestBruteCollinearPoints.java:741)

  * filename = input40.txt

    java.lang.NullPointerException: segment 0 is null

    TestBruteCollinearPoints.toLineSegments226(TestBruteCollinearPoints.java:48)
    TestBruteCollinearPoints.testSegments(TestBruteCollinearPoints.java:109)
    TestBruteCollinearPoints.file(TestBruteCollinearPoints.java:150)
    TestBruteCollinearPoints.test6(TestBruteCollinearPoints.java:295)
    TestBruteCollinearPoints.main(TestBruteCollinearPoints.java:741)

  * filename = input48.txt

    java.lang.NullPointerException: segment 0 is null

    TestBruteCollinearPoints.toLineSegments226(TestBruteCollinearPoints.java:48)
    TestBruteCollinearPoints.testSegments(TestBruteCollinearPoints.java:109)
    TestBruteCollinearPoints.file(TestBruteCollinearPoints.java:150)
    TestBruteCollinearPoints.test6(TestBruteCollinearPoints.java:296)
    TestBruteCollinearPoints.main(TestBruteCollinearPoints.java:741)

==> FAILED

Test 7: check for fragile dependence on return value of toString()
  * filename = equidistant.txt

    java.lang.NullPointerException: segment 0 is null

    TestBruteCollinearPoints.toLineSegments226(TestBruteCollinearPoints.java:48)
    TestBruteCollinearPoints.testSegments(TestBruteCollinearPoints.java:109)
    TestBruteCollinearPoints.file(TestBruteCollinearPoints.java:150)
    TestBruteCollinearPoints.test7(TestBruteCollinearPoints.java:304)
    TestBruteCollinearPoints.main(TestBruteCollinearPoints.java:744)

  * filename = input40.txt

    java.lang.NullPointerException: segment 0 is null

    TestBruteCollinearPoints.toLineSegments226(TestBruteCollinearPoints.java:48)
    TestBruteCollinearPoints.testSegments(TestBruteCollinearPoints.java:109)
    TestBruteCollinearPoints.file(TestBruteCollinearPoints.java:150)
    TestBruteCollinearPoints.test7(TestBruteCollinearPoints.java:305)
    TestBruteCollinearPoints.main(TestBruteCollinearPoints.java:744)

  * filename = input48.txt

    java.lang.NullPointerException: segment 0 is null

    TestBruteCollinearPoints.toLineSegments226(TestBruteCollinearPoints.java:48)
    TestBruteCollinearPoints.testSegments(TestBruteCollinearPoints.java:109)
    TestBruteCollinearPoints.file(TestBruteCollinearPoints.java:150)
    TestBruteCollinearPoints.test7(TestBruteCollinearPoints.java:306)
    TestBruteCollinearPoints.main(TestBruteCollinearPoints.java:744)


It is bad style to write code that depends on the particular format of
the output from the toString() method, especially if your reason for
doing so is to circumvent the public API (which intentionally does not
provide access to the x- and y-coordinates).

==> FAILED

Test 8: random line segments, none vertical or horizontal
  *  1 random line segment
  *  5 random line segments

    java.lang.NullPointerException: segment 0 is null

    TestBruteCollinearPoints.toLineSegments226(TestBruteCollinearPoints.java:48)
    TestBruteCollinearPoints.testSegments(TestBruteCollinearPoints.java:109)
    TestBruteCollinearPoints.noVerticalOrHorizontalSegments(TestBruteCollinearPoints.java:328)
    TestBruteCollinearPoints.test8(TestBruteCollinearPoints.java:347)
    TestBruteCollinearPoints.main(TestBruteCollinearPoints.java:747)

    - failed on trial 1 of 250
     20
      9017 16712
     10044 15154
     12836 10955
     12015 16012
      6877 12322
      7416 14010
     11358 15726
      3166  1115
     13122 10227
     14354 11195
     13066 10183
     12702  9897
      1887  8086
      7620 15340
      3798 10504
     13803 11939
     17671 15875
      7733 14078
      5072 12116
      1741  1786

  * 10 random line segments

    java.lang.NullPointerException: segment 0 is null

    TestBruteCollinearPoints.toLineSegments226(TestBruteCollinearPoints.java:48)
    TestBruteCollinearPoints.testSegments(TestBruteCollinearPoints.java:109)
    TestBruteCollinearPoints.noVerticalOrHorizontalSegments(TestBruteCollinearPoints.java:328)
    TestBruteCollinearPoints.test8(TestBruteCollinearPoints.java:348)
    TestBruteCollinearPoints.main(TestBruteCollinearPoints.java:747)

    - failed on trial 1 of 100

  * 15 random line segments

    java.lang.NullPointerException: segment 0 is null

    TestBruteCollinearPoints.toLineSegments226(TestBruteCollinearPoints.java:48)
    TestBruteCollinearPoints.testSegments(TestBruteCollinearPoints.java:109)
    TestBruteCollinearPoints.noVerticalOrHorizontalSegments(TestBruteCollinearPoints.java:328)
    TestBruteCollinearPoints.test8(TestBruteCollinearPoints.java:349)
    TestBruteCollinearPoints.main(TestBruteCollinearPoints.java:747)

    - failed on trial 1 of 50

==> FAILED

Test 9: random line segments
  *  1 random line segment
  *  5 random line segments

    java.lang.NullPointerException: segment 0 is null

    TestBruteCollinearPoints.toLineSegments226(TestBruteCollinearPoints.java:48)
    TestBruteCollinearPoints.testSegments(TestBruteCollinearPoints.java:109)
    TestBruteCollinearPoints.arbitrarySegments(TestBruteCollinearPoints.java:361)
    TestBruteCollinearPoints.test9(TestBruteCollinearPoints.java:380)
    TestBruteCollinearPoints.main(TestBruteCollinearPoints.java:750)

    - failed on trial 1 of 250
     20
     14610 13868
       922  7146
      5964  7917
     11287  9279
     11287 13940
     13152  8036
      5829  5997
      2803  8818
      2704  8730
      5925  5031
      6664 12250
     11287 13291
     11287 13881
      5829  6653
     14124 11924
      5959  7547
     14340 12788
      5829  6309
      5829  6517
      5929  5327

  * 10 random line segments

    java.lang.NullPointerException: segment 0 is null

    TestBruteCollinearPoints.toLineSegments226(TestBruteCollinearPoints.java:48)
    TestBruteCollinearPoints.testSegments(TestBruteCollinearPoints.java:109)
    TestBruteCollinearPoints.arbitrarySegments(TestBruteCollinearPoints.java:361)
    TestBruteCollinearPoints.test9(TestBruteCollinearPoints.java:381)
    TestBruteCollinearPoints.main(TestBruteCollinearPoints.java:750)

    - failed on trial 1 of 100

  * 15 random line segments

    java.lang.NullPointerException: segment 0 is null

    TestBruteCollinearPoints.toLineSegments226(TestBruteCollinearPoints.java:48)
    TestBruteCollinearPoints.testSegments(TestBruteCollinearPoints.java:109)
    TestBruteCollinearPoints.arbitrarySegments(TestBruteCollinearPoints.java:361)
    TestBruteCollinearPoints.test9(TestBruteCollinearPoints.java:382)
    TestBruteCollinearPoints.main(TestBruteCollinearPoints.java:750)

    - failed on trial 1 of 50

==> FAILED

Test 10: check that data type is immutable by testing whether each method
         returns the same value, regardless of any intervening operations
  * input8.txt

    java.lang.NullPointerException

    BruteCollinearPoints.segments(BruteCollinearPoints.java:54)
    BruteCollinearPoints.numberOfSegments(BruteCollinearPoints.java:38)
    TestBruteCollinearPoints.testImmutable(TestBruteCollinearPoints.java:438)
    TestBruteCollinearPoints.testImmutable(TestBruteCollinearPoints.java:516)
    TestBruteCollinearPoints.test10(TestBruteCollinearPoints.java:531)
    TestBruteCollinearPoints.main(TestBruteCollinearPoints.java:753)

    - sequence of operations was:
          BruteCollinearPoints collinear = new BruteCollinearPoints(points);
          collinear.numberOfSegments() -> 1
          collinear.segments()
          collinear.segments()
          collinear.numberOfSegments() -> 1
          collinear.segments()
          mutate array returned by last call to segments()
          mutate array returned by last call to segments()
          collinear.numberOfSegments() -> 1
          mutate array returned by last call to segments()
          mutate array returned by last call to segments()
          collinear.numberOfSegments() -> 1
          mutate points[] array that was passed to constructor
          mutate array returned by last call to segments()
          mutate array returned by last call to segments()
          collinear.numberOfSegments()

    - failed on trial 1 of 100

  * equidistant.txt

    java.lang.NullPointerException

    BruteCollinearPoints.segments(BruteCollinearPoints.java:54)
    BruteCollinearPoints.numberOfSegments(BruteCollinearPoints.java:38)
    TestBruteCollinearPoints.testImmutable(TestBruteCollinearPoints.java:438)
    TestBruteCollinearPoints.testImmutable(TestBruteCollinearPoints.java:516)
    TestBruteCollinearPoints.test10(TestBruteCollinearPoints.java:532)
    TestBruteCollinearPoints.main(TestBruteCollinearPoints.java:753)

    - sequence of operations was:
          BruteCollinearPoints collinear = new BruteCollinearPoints(points);
          mutate points[] array that was passed to constructor
          mutate points[] array that was passed to constructor
          collinear.numberOfSegments()

    - failed on trial 1 of 100

==> FAILED

Test 11: check that data type does not mutate the constructor argument
  * input8.txt
  * equidistant.txt
==> passed

Test 12: numberOfSegments() is consistent with segments()
  * filename = input8.txt
  * filename = equidistant.txt
  * filename = input40.txt
  * filename = input48.txt
  * filename = horizontal5.txt
  * filename = vertical5.txt
  * filename = random23.txt
==> passed

Test 13: throws an exception if either the constructor argument is null
         or any entry in array is null
  * argument is null
    - constructor throws wrong exception
    - constructor throws a java.lang.NullPointerException
    - constructor should throw a java.lang.IllegalArgumentException
     0

  * Point[] of length 10, number of null entries = 1
    - constructor throws wrong exception
    - constructor throws a java.lang.NullPointerException
    - constructor should throw a java.lang.IllegalArgumentException
     10
     15112 12085
     21980 17091
     20859   529
     null
     14203  4033
     21563  1547
     20035 18772
     26974 20833
     24502  5886
     25983 17862

  * Point[] of length 10, number of null entries = 10
  * Point[] of length 4, number of null entries = 1
  * Point[] of length 3, number of null entries = 1
    - constructor throws wrong exception
    - constructor throws a java.lang.NullPointerException
    - constructor should throw a java.lang.IllegalArgumentException
     3
       958 11664
     null
      2818  8697

  * Point[] of length 2, number of null entries = 1
  * Point[] of length 1, number of null entries = 1
    - constructor fails to throw an exception
     1
     null

==> FAILED

Test 14: check that the constructor throws an exception if duplicate points
  * 50 points
  * 25 points
  * 5 points
  * 4 points
  * 3 points
  * 2 points
==> passed


Total: 3/17 tests passed!


================================================================
Testing correctness of FastCollinearPoints
*-----------------------------------------------------------
Running 21 total tests.

The inputs satisfy the following conditions:
  - no duplicate points
  - all x- and y-coordinates between 0 and 32,767

Test 1: points from a file
  * filename = input8.txt
  * filename = equidistant.txt
    - segments() contains the same segment more than once
    - segment 1: (10000, 0) -> (0, 30000)
    - segment 3: (10000, 0) -> (0, 30000)

    - number of entries in student   solution: 4
    - number of entries in reference solution: 4
    - 4 extra entries in student solution, including:
      '(18000, 2000) -> (2000, 18000)'

    - 4 missing entries in student solution, including:
      '(30000, 0) -> (20000, 10000) -> (10000, 20000) -> (0, 30000)'


  * filename = input40.txt
    - segments() contains the same segment more than once
    - segment 13: (26000, 8000) -> (1000, 31000)
    - segment 15: (26000, 8000) -> (1000, 31000)

    - number of entries in student   solution: 42
    - number of entries in reference solution: 4
    - 42 extra entries in student solution, including:
      '(22000, 29000) -> (10000, 31000)'

    - 4 missing entries in student solution, including:
      '(2000, 29000) -> (4000, 29000) -> (22000, 29000) -> (28000, 29000)'


  * filename = input48.txt
    - segments() contains the same segment more than once
    - segment 10: (18000, 13000) -> (23000, 29000)
    - segment 20: (18000, 13000) -> (23000, 29000)

    - number of entries in student   solution: 69
    - number of entries in reference solution: 6
    - 69 extra entries in student solution, including:
      '(5000, 29000) -> (17000, 31000)'

    - 6 missing entries in student solution, including:
      '(1000, 26000) -> (9000, 26000) -> (11000, 26000) -> (18000, 26000)'


  * filename = input299.txt
    - segments() contains the same segment more than once
    - segment 58: (29050, 5250) -> (16900, 32700)
    - segment 200: (29050, 5250) -> (16900, 32700)

    - number of entries in student   solution: 534
    - number of entries in reference solution: 6
    - 534 extra entries in student solution, including:
      '(600, 31900) -> (1000, 32650)'

    - 6 missing entries in student solution, including:
      '(3250, 17450) -> (8500, 17450) -> (13400, 17450) -> (17250, 17450)'


==> FAILED

Test 2a: points from a file with horizontal line segments
  * filename = horizontal5.txt
    - number of entries in student   solution: 1
    - number of entries in reference solution: 5
    - 1 extra entry in student solution:
      '(5766, 4652) -> (7821, 14118)'

    - 5 missing entries in student solution, including:
      '(2682, 14118) -> (5067, 14118) -> (7453, 14118) -> (7821, 14118)'


  * filename = horizontal25.txt
    - number of entries in student   solution: 1
    - number of entries in reference solution: 25
    - 1 extra entry in student solution:
      '(10021, 1256) -> (19666, 20913)'

    - 25 missing entries in student solution, including:
      '(8784, 20913) -> (9880, 20913) -> (16352, 20913) -> (19666, 20913)'


  * filename = horizontal50.txt
    - number of entries in student   solution: 1
    - number of entries in reference solution: 50
    - 1 extra entry in student solution:
      '(2624, 1040) -> (17428, 20754)'

    - 50 missing entries in student solution, including:
      '(5249, 20754) -> (5559, 20754) -> (14800, 20754) -> (17428, 20754)'


  * filename = horizontal75.txt
    - number of entries in student   solution: 2
    - number of entries in reference solution: 75
    - 2 extra entries in student solution, including:
      '(14707, 6016) -> (13795, 12628)'

    - 75 missing entries in student solution, including:
      '(1536, 20976) -> (6545, 20976) -> (14178, 20976) -> (14591, 20976)'


  * filename = horizontal100.txt
    - number of entries in student   solution: 2
    - number of entries in reference solution: 100
    - 2 extra entries in student solution, including:
      '(1672, 13404) -> (2656, 14586)'

    - 100 missing entries in student solution, including:
      '(5835, 20698) -> (7673, 20698) -> (16154, 20698) -> (19642, 20698)'


==> FAILED

Test 2b: random horizontal line segments
  *  1 random horizontal line segment
    - segments() contains a subsegment of a segment in reference solution
    - student   segment 0: (5979, 5505) -> (10625, 5505)
    - reference segment 0: (5979, 5505) -> (10625, 5505) -> (13683, 5505) -> (17972, 5505)

    - number of entries in student   solution: 1
    - number of entries in reference solution: 1
    - 1 extra entry in student solution:
      '(5979, 5505) -> (10625, 5505)'

    - 1 missing entry in student solution:
      '(5979, 5505) -> (10625, 5505) -> (13683, 5505) -> (17972, 5505)'


    - failed on trial 2 of 500
     4
     10625  5505
      5979  5505
     17972  5505
     13683  5505

  *  5 random horizontal line segments
    - number of entries in student   solution: 1
    - number of entries in reference solution: 5
    - 1 extra entry in student solution:
      '(1910, 1984) -> (18279, 18581)'

    - 5 missing entries in student solution, including:
      '(8411, 18581) -> (8584, 18581) -> (14633, 18581) -> (18279, 18581)'


    - failed on trial 1 of 250
     20
     11383 12911
     11518 10617
      7525  1984
     19653 12911
     14633 18581
     20082 10617
     11184 16642
      8584 18581
      8411 18581
     16567 10617
      4400  1984
     18279 18581
      2419 10617
      7174 12911
     19195 12911
     11374 16642
      6952 16642
      1910  1984
     17127  1984
     15977 16642

  * 10 random horizontal line segments
    - number of entries in student   solution: 1
    - number of entries in reference solution: 10
    - 1 extra entry in student solution:
      '(14788, 3293) -> (13680, 19782)'

    - 10 missing entries in student solution, including:
      '(4941, 19782) -> (4998, 19782) -> (8977, 19782) -> (13680, 19782)'


    - failed on trial 1 of 50

  * 15 random horizontal line segments
    - number of entries in student   solution: 1
    - number of entries in reference solution: 15
    - 1 extra entry in student solution:
      '(3547, 2809) -> (19862, 20780)'

    - 15 missing entries in student solution, including:
      '(4185, 20780) -> (11157, 20780) -> (15301, 20780) -> (19862, 20780)'


    - failed on trial 1 of 5

==> FAILED

Test 3a: points from a file with vertical line segments
  * filename = vertical5.txt
    - number of entries in student   solution: 1
    - number of entries in reference solution: 5
    - 1 extra entry in student solution:
      '(8421, 1829) -> (5757, 20856)'

    - 5 missing entries in student solution, including:
      '(14407, 10367) -> (14407, 17188) -> (14407, 17831) -> (14407, 19953)'


  * filename = vertical25.txt
    - number of entries in student   solution: 1
    - number of entries in reference solution: 25
    - 1 extra entry in student solution:
      '(9557, 1388) -> (13536, 20946)'

    - 25 missing entries in student solution, including:
      '(19953, 10489) -> (19953, 10688) -> (19953, 19299) -> (19953, 20439)'


  * filename = vertical50.txt
    - number of entries in student   solution: 1
    - number of entries in reference solution: 50
    - 1 extra entry in student solution:
      '(10209, 1143) -> (10695, 20927)'

    - 50 missing entries in student solution, including:
      '(5991, 15606) -> (5991, 20227) -> (5991, 20340) -> (5991, 20424)'


  * filename = vertical75.txt
    - number of entries in student   solution: 1
    - number of entries in reference solution: 75
    - 1 extra entry in student solution:
      '(9632, 1012) -> (18293, 20983)'

    - 75 missing entries in student solution, including:
      '(13780, 16365) -> (13780, 17494) -> (13780, 18253) -> (13780, 18908)'


  * filename = vertical100.txt
    - number of entries in student   solution: 2
    - number of entries in reference solution: 100
    - 2 extra entries in student solution, including:
      '(2977, 15792) -> (18009, 18793)'

    - 100 missing entries in student solution, including:
      '(15135, 15588) -> (15135, 17398) -> (15135, 19476) -> (15135, 20439)'


==> FAILED

Test 3b: random vertical line segments
  *  1 random vertical line segment
    - segments() contains a subsegment of a segment in reference solution
    - student   segment 0: (14493, 4142) -> (14493, 10476)
    - reference segment 0: (14493, 4142) -> (14493, 10476) -> (14493, 13582) -> (14493, 18284)

    - number of entries in student   solution: 1
    - number of entries in reference solution: 1
    - 1 extra entry in student solution:
      '(14493, 4142) -> (14493, 10476)'

    - 1 missing entry in student solution:
      '(14493, 4142) -> (14493, 10476) -> (14493, 13582) -> (14493, 18284)'


    - failed on trial 2 of 500
     4
     14493  4142
     14493 13582
     14493 10476
     14493 18284

  *  5 random vertical line segments
    - number of entries in student   solution: 1
    - number of entries in reference solution: 5
    - 1 extra entry in student solution:
      '(13786, 2006) -> (10238, 20379)'

    - 5 missing entries in student solution, including:
      '(12164, 12503) -> (12164, 14995) -> (12164, 15711) -> (12164, 15952)'


    - failed on trial 1 of 250
     20
     10238 20379
     12164 15952
      7753 16631
     13786  7445
     10238  3975
     12164 12503
      7753 12020
      4108 16957
     12164 14995
      4108  3741
     12164 15711
     10238 19922
     13786  2006
      4108  2481
     13786 15452
     10238 18764
      7753 14838
     13786 15896
      7753  2867
      4108 10560

  * 10 random vertical line segments
    - number of entries in student   solution: 1
    - number of entries in reference solution: 10
    - 1 extra entry in student solution:
      '(13976, 1214) -> (17005, 20740)'

    - 10 missing entries in student solution, including:
      '(17005, 12048) -> (17005, 14179) -> (17005, 18081) -> (17005, 20740)'


    - failed on trial 1 of 50

  * 15 random vertical line segments
    - number of entries in student   solution: 1
    - number of entries in reference solution: 15
    - 1 extra entry in student solution:
      '(20413, 1964) -> (15681, 20967)'

    - 15 missing entries in student solution, including:
      '(17413, 10453) -> (17413, 11016) -> (17413, 13039) -> (17413, 19576)'


    - failed on trial 1 of 5

==> FAILED

Test 4a: points from a file with no line segments
  * filename = random23.txt
  * filename = random38.txt
  * filename = random91.txt
  * filename = random152.txt
==> passed

Test 4b: random points with no line segments
  *  5 random points
  * 10 random points
  * 20 random points
  * 50 random points
==> passed

Test 5a: points from a file with 5 or more on some line segments
  * filename = input9.txt
  * filename = input10.txt
    - segments() contains a subsegment of a segment in reference solution
    - student   segment 0: (23000, 16000) -> (3000, 26000)
    - reference segment 0: (28000, 13500) -> (23000, 16000) -> (13000, 21000) -> (3000, 26000)

    - number of entries in student   solution: 2
    - number of entries in reference solution: 2
    - 1 extra entry in student solution:
      '(23000, 16000) -> (3000, 26000)'

    - 1 missing entry in student solution:
      '(28000, 13500) -> (23000, 16000) -> (13000, 21000) -> (3000, 26000)'


  * filename = input20.txt
    - segments() contains the same segment more than once
    - segment 0: (7168, 25088) -> (7168, 29184)
    - segment 1: (7168, 25088) -> (7168, 29184)

    - number of entries in student   solution: 13
    - number of entries in reference solution: 5
    - 13 extra entries in student solution, including:
      '(8192, 26112) -> (7168, 29184)'

    - 5 missing entries in student solution, including:
      '(4160, 29184) -> (5120, 29184) -> (6144, 29184) -> (7168, 29184) -> (8192, 29184)'


  * filename = input50.txt
    - segments() contains the same segment more than once
    - segment 12: (25000, 1000) -> (9000, 29000)
    - segment 22: (25000, 1000) -> (9000, 29000)

    - number of entries in student   solution: 75
    - number of entries in reference solution: 7
    - 74 extra entries in student solution, including:
      '(5000, 29000) -> (17000, 31000)'

    - 6 missing entries in student solution, including:
      '(1000, 26000) -> (9000, 26000) -> (11000, 26000) -> (18000, 26000)'


  * filename = input80.txt
    - segments() contains the same segment more than once
    - segment 32: (15000, 0) -> (27000, 31000)
    - segment 38: (15000, 0) -> (27000, 31000)

    - segments() contains a subsegment of a segment in reference solution
    - student   segment 63: (25000, 8000) -> (25000, 27000)
    - reference segment 28: (25000, 8000) -> (25000, 9000) -> (25000, 12000) -> (25000, 27000) -> (25000, 29000) -> (25000, 31000)

    - number of entries in student   solution: 250
    - number of entries in reference solution: 31
    - 248 extra entries in student solution, including:
      '(15000, 30000) -> (29000, 31000)'

    - 29 missing entries in student solution, including:
      '(13000, 29000) -> (19000, 29000) -> (25000, 29000) -> (28000, 29000)'


  * filename = input300.txt
    - segments() contains the same segment more than once
    - segment 60: (29050, 5250) -> (16900, 32700)
    - segment 203: (29050, 5250) -> (16900, 32700)

    - number of entries in student   solution: 539
    - number of entries in reference solution: 6
    - 539 extra entries in student solution, including:
      '(600, 31900) -> (1000, 32650)'

    - 6 missing entries in student solution, including:
      '(3250, 17450) -> (8500, 17450) -> (13400, 17450) -> (17250, 17450)'


  * filename = inarow.txt
    - number of entries in student   solution: 6
    - number of entries in reference solution: 5
    - 3 extra entries in student solution, including:
      '(20000, 0) -> (0, 30000)'

    - 2 missing entries in student solution, including:
      '(30000, 0) -> (27000, 7500) -> (26000, 10000) -> (20000, 25000) -> (19000, 27500) -> (18000, 30000)'


==> FAILED

Test 5b: points from a file with 5 or more on some line segments
  * filename = kw1260.txt
    - segments() contains the same segment more than once
    - segment 2: (14820, 5966) -> (14557, 18640)
    - segment 4: (14820, 5966) -> (14557, 18640)

    - number of entries in student   solution: 1446
    - number of entries in reference solution: 288
    - 1355 extra entries in student solution, including:
      '(15574, 30361) -> (14236, 30449)'

    - 197 missing entries in student solution, including:
      '(16384, 30255) -> (15979, 30308) -> (15574, 30361) -> (15169, 30414) -> (14764, 30467)'


  * filename = rs1423.txt
    - segments() contains the same segment more than once
    - segment 52: (12936, 14466) -> (13685, 27948)
    - segment 1413: (12936, 14466) -> (13685, 27948)

    - segments() contains a subsegment of a segment in reference solution
    - student   segment 2: (31442, 1260) -> (31440, 1860)
    - reference segment 1: (31443, 960) -> (31442, 1260) -> (31441, 1560) -> (31440, 1860)

    - number of entries in student   solution: 1446
    - number of entries in reference solution: 443
    - 1285 extra entries in student solution, including:
      '(13927, 27810) -> (13443, 28086)'

    - 282 missing entries in student solution, including:
      '(14169, 27672) -> (13927, 27810) -> (13685, 27948) -> (13443, 28086)'


==> FAILED

Test 6: points from a file with fewer than 4 points
  * filename = input1.txt
  * filename = input2.txt
  * filename = input3.txt
==> passed

Test 7: check for dependence on either compareTo() or compare()
        returning { -1, +1, 0 } instead of { negative integer,
        positive integer, zero }
  * filename = equidistant.txt
    - segments() contains the same segment more than once
    - segment 1: (10000, 0) -> (0, 30000)
    - segment 3: (10000, 0) -> (0, 30000)

    - number of entries in student   solution: 4
    - number of entries in reference solution: 4
    - 4 extra entries in student solution, including:
      '(18000, 2000) -> (2000, 18000)'

    - 4 missing entries in student solution, including:
      '(30000, 0) -> (20000, 10000) -> (10000, 20000) -> (0, 30000)'


  * filename = input40.txt
    - segments() contains the same segment more than once
    - segment 13: (26000, 8000) -> (1000, 31000)
    - segment 15: (26000, 8000) -> (1000, 31000)

    - number of entries in student   solution: 42
    - number of entries in reference solution: 4
    - 42 extra entries in student solution, including:
      '(22000, 29000) -> (10000, 31000)'

    - 4 missing entries in student solution, including:
      '(2000, 29000) -> (4000, 29000) -> (22000, 29000) -> (28000, 29000)'


  * filename = input48.txt
    - segments() contains the same segment more than once
    - segment 10: (18000, 13000) -> (23000, 29000)
    - segment 20: (18000, 13000) -> (23000, 29000)

    - number of entries in student   solution: 69
    - number of entries in reference solution: 6
    - 69 extra entries in student solution, including:
      '(5000, 29000) -> (17000, 31000)'

    - 6 missing entries in student solution, including:
      '(1000, 26000) -> (9000, 26000) -> (11000, 26000) -> (18000, 26000)'


  * filename = input299.txt
    - segments() contains the same segment more than once
    - segment 58: (29050, 5250) -> (16900, 32700)
    - segment 200: (29050, 5250) -> (16900, 32700)

    - number of entries in student   solution: 534
    - number of entries in reference solution: 6
    - 534 extra entries in student solution, including:
      '(600, 31900) -> (1000, 32650)'

    - 6 missing entries in student solution, including:
      '(3250, 17450) -> (8500, 17450) -> (13400, 17450) -> (17250, 17450)'


==> FAILED

Test 8: check for fragile dependence on return value of toString()
  * filename = equidistant.txt
    - segments() contains the same segment more than once
    - segment 1: (10000, 0) -> (0, 30000)
    - segment 3: (10000, 0) -> (0, 30000)

    - number of entries in student   solution: 4
    - number of entries in reference solution: 4
    - 4 extra entries in student solution, including:
      '(18000, 2000) -> (2000, 18000)'

    - 4 missing entries in student solution, including:
      '(30000, 0) -> (20000, 10000) -> (10000, 20000) -> (0, 30000)'


  * filename = input40.txt
    - segments() contains the same segment more than once
    - segment 13: (26000, 8000) -> (1000, 31000)
    - segment 15: (26000, 8000) -> (1000, 31000)

    - number of entries in student   solution: 42
    - number of entries in reference solution: 4
    - 42 extra entries in student solution, including:
      '(22000, 29000) -> (10000, 31000)'

    - 4 missing entries in student solution, including:
      '(2000, 29000) -> (4000, 29000) -> (22000, 29000) -> (28000, 29000)'


  * filename = input48.txt
    - segments() contains the same segment more than once
    - segment 10: (18000, 13000) -> (23000, 29000)
    - segment 20: (18000, 13000) -> (23000, 29000)

    - number of entries in student   solution: 69
    - number of entries in reference solution: 6
    - 69 extra entries in student solution, including:
      '(5000, 29000) -> (17000, 31000)'

    - 6 missing entries in student solution, including:
      '(1000, 26000) -> (9000, 26000) -> (11000, 26000) -> (18000, 26000)'



It is bad style to write code that depends on the particular format of
the output from the toString() method, especially if your reason for
doing so is to circumvent the public API (which intentionally does not
provide access to the x- and y-coordinates).

==> FAILED

Test 9: random line segments, none vertical or horizontal
  *  1 random line segment
    - segments() contains a subsegment of a segment in reference solution
    - student   segment 0: (1819, 3058) -> (7021, 5668)
    - reference segment 0: (1819, 3058) -> (7021, 5668) -> (8177, 6248) -> (9911, 7118)

    - number of entries in student   solution: 1
    - number of entries in reference solution: 1
    - 1 extra entry in student solution:
      '(1819, 3058) -> (7021, 5668)'

    - 1 missing entry in student solution:
      '(1819, 3058) -> (7021, 5668) -> (8177, 6248) -> (9911, 7118)'


    - failed on trial 1 of 500
     4
      7021  5668
      8177  6248
      9911  7118
      1819  3058

  *  5 random line segments
    - segments() contains a subsegment of a segment in reference solution
    - student   segment 3: (7454, 2711) -> (14470, 10431)
    - reference segment 3: (5700, 781) -> (7454, 2711) -> (9208, 4641) -> (14470, 10431)

    - number of entries in student   solution: 5
    - number of entries in reference solution: 5
    - 1 extra entry in student solution:
      '(7454, 2711) -> (14470, 10431)'

    - 1 missing entry in student solution:
      '(5700, 781) -> (7454, 2711) -> (9208, 4641) -> (14470, 10431)'


    - failed on trial 1 of 500
     20
      4928  6745
      6185  1696
      7454  2711
     13380  8409
      8987  4543
      9208  4641
     14470 10431
     11968  8901
     16591 16340
     11808  8852
     14746 12745
     11789  7390
     12723  8339
     13270  9869
     15115 13464
     15819 10506
      5700   781
      7328  7480
     14193  9108
     16632 11205

  * 25 random line segments
    - segments() contains a subsegment of a segment in reference solution
    - student   segment 2: (6049, 6707) -> (16825, 8879)
    - reference segment 2: (661, 5621) -> (6049, 6707) -> (14131, 8336) -> (16825, 8879)

    - number of entries in student   solution: 25
    - number of entries in reference solution: 25
    - 6 extra entries in student solution, including:
      '(1018, 7949) -> (23282, 19035)'

    - 6 missing entries in student solution, including:
      '(50, 7467) -> (1018, 7949) -> (13602, 14215) -> (23282, 19035)'


    - failed on trial 1 of 100

  * 50 random line segments
    - segments() contains a subsegment of a segment in reference solution
    - student   segment 6: (2290, 4933) -> (12562, 6445)
    - reference segment 6: (578, 4681) -> (2290, 4933) -> (11706, 6319) -> (12562, 6445)

    - number of entries in student   solution: 50
    - number of entries in reference solution: 50
    - 12 extra entries in student solution, including:
      '(9779, 14530) -> (11689, 16266)'

    - 12 missing entries in student solution, including:
      '(7860, 12150) -> (10686, 13926) -> (15396, 16886) -> (16338, 17478)'


    - failed on trial 1 of 15

  * 100 random line segments
    - segments() contains a subsegment of a segment in reference solution
    - student   segment 11: (10146, 11360) -> (14742, 12350)
    - reference segment 9: (8614, 11030) -> (10146, 11360) -> (13210, 12020) -> (14742, 12350)

    - number of entries in student   solution: 103
    - number of entries in reference solution: 100
    - 27 extra entries in student solution, including:
      '(14715, 17802) -> (20827, 17802)'

    - 24 missing entries in student solution, including:
      '(8820, 13014) -> (10323, 14655) -> (10824, 15202) -> (12327, 16843)'


    - failed on trial 1 of 2

==> FAILED

Test 10: random line segments
  *  1 random line segment
    - segments() contains a subsegment of a segment in reference solution
    - student   segment 0: (6770, 4113) -> (7055, 4263)
    - reference segment 0: (6770, 4113) -> (7055, 4263) -> (9525, 5563) -> (10

...

WARNING: the grading output was truncated due to excessive length.
Typically, this is because you have a method that has an unanticipated side effect
(such as printing to standard output or throwing an exception). A large amount of output
can also arise from failing many tests.
