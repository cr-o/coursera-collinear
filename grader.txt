See the Assessment Guide for information on how to interpret this report.

ASSESSMENT SUMMARY

Compilation:  PASSED
API:          PASSED

Spotbugs:     FAILED (18 warnings)
PMD:          FAILED (13 warnings)
Checkstyle:   FAILED (0 errors, 2 warnings)

Correctness:  10/41 tests passed
Memory:       1/1 tests passed
Timing:       0/41 tests passed

Aggregate score: 34.63%
[Compilation: 5%, API: 5%, Spotbugs: 0%, PMD: 0%, Checkstyle: 0%, Correctness: 60%, Memory: 10%, Timing: 20%]

ASSESSMENT DETAILS

The following files were submitted:
----------------------------------
5.5K Jan  6 14:29 BruteCollinearPoints.java
8.2K Jan  6 14:29 FastCollinearPoints.java
4.3K Jan  6 14:29 Point.java


********************************************************************************
*  COMPILING
********************************************************************************


% javac11 Point.java
*-----------------------------------------------------------

% javac11 LineSegment.java
*-----------------------------------------------------------

% javac11 BruteCollinearPoints.java
*-----------------------------------------------------------

% javac11 FastCollinearPoints.java
*-----------------------------------------------------------


================================================================


Checking the APIs of your programs.
*-----------------------------------------------------------
Point:

BruteCollinearPoints:

FastCollinearPoints:

================================================================


********************************************************************************
*  CHECKING STYLE AND COMMON BUG PATTERNS
********************************************************************************


% spotbugs *.class
*-----------------------------------------------------------
M D UC_USELESS_OBJECT UC: The object stored in the variable 'pt' is created and modified, but its value never goes outside of the method 'main()' or produces any side effect.  At Point.java:[line 133]
M D UC_USELESS_OBJECT UC: The object stored in the variable 'pt2' is created and modified, but its value never goes outside of the method 'main()' or produces any side effect.  At Point.java:[line 134]
M D DLS_DEAD_LOCAL_STORE DLS: Assigns a value to the local variable 'slopeResult' but that value is never used.  At Point.java:[line 136]
M D DLS_DEAD_LOCAL_STORE DLS: Assigns a value to the local variable 'comparator' but that value is never used.  At Point.java:[line 137]
M D DLS_DEAD_LOCAL_STORE DLS: Assigns a value to the local variable 'compareResult' but that value is never used.  At Point.java:[line 135]
L D FE_FLOATING_POINT_EQUALITY FE: Tests for exact floating-point equality. Because floating-point calculations may involve rounding, the calculated values may be imprecise.  At Point.java:[line 68]
H D UC_USELESS_VOID_METHOD UC: The void method 'main()' appears to serve no purpose.  At Point.java:[line 139]
M V EI_EXPOSE_REP2 EI2: Stores a reference to an externally mutable object in the instance variable 'points', exposing the internal representation of the class 'BruteCollinearPoints'. Instead, create a defensive copy of the object referenced by the parameter variable 'points' and store that copy in the instance variable 'points'.  At BruteCollinearPoints.java:[line 23]
L D PZLA_PREFER_ZERO_LENGTH_ARRAYS PZLA: Should 'segments()' return a zero-length array instead of null?  At BruteCollinearPoints.java:[line 97]
L D FE_FLOATING_POINT_EQUALITY FE: Tests for exact floating-point equality. Because floating-point calculations may involve rounding, the calculated values may be imprecise.  At BruteCollinearPoints.java:[line 69]
M V EI_EXPOSE_REP2 EI2: Stores a reference to an externally mutable object in the instance variable 'points', exposing the internal representation of the class 'FastCollinearPoints'. Instead, create a defensive copy of the object referenced by the parameter variable 'points' and store that copy in the instance variable 'points'.  At FastCollinearPoints.java:[line 23]
L D FE_FLOATING_POINT_EQUALITY FE: Tests for exact floating-point equality. Because floating-point calculations may involve rounding, the calculated values may be imprecise.  At FastCollinearPoints.java:[line 83]
M P URF_UNREAD_FIELD UrF: The instance (or static) variable 'point' is never read. Consider removing it from the class.  At BruteCollinearPoints.java:[line 48]
L P SIC_INNER_SHOULD_BE_STATIC_ANON SIC: Should the anonymous inner class 'BruteCollinearPoints$1' be refactored into a named static nested class?  At BruteCollinearPoints.java:[line 102]
M P URF_UNREAD_FIELD UrF: The instance (or static) variable 'slopeToOrigin' is never read. Consider removing it from the class.  At BruteCollinearPoints.java:[line 49]
L P SIC_INNER_SHOULD_BE_STATIC_ANON SIC: Should the anonymous inner class 'FastCollinearPoints$1' be refactored into a named static nested class?  At FastCollinearPoints.java:[line 160]
L P SIC_INNER_SHOULD_BE_STATIC_ANON SIC: Should the anonymous inner class 'FastCollinearPoints$2' be refactored into a named static nested class?  At FastCollinearPoints.java:[line 168]
M P URF_UNREAD_FIELD UrF: The instance (or static) variable 'origin' is never read. Consider removing it from the class.  At BruteCollinearPoints.java:[line 47]
Warnings generated: 18


================================================================


% pmd .
*-----------------------------------------------------------
BruteCollinearPoints.java:17: The private instance (or static) variable 'points' can be made 'final'; it is initialized only in the declaration or constructor. [ImmutableField]
BruteCollinearPoints.java:19: The user-supplied array 'points' is stored directly. [ArrayIsStoredDirectly]
BruteCollinearPoints.java:42: The private instance (or static) variable 'origin' can be made 'final'; it is initialized only in the declaration or constructor. [ImmutableField]
BruteCollinearPoints.java:43: The private instance (or static) variable 'point' can be made 'final'; it is initialized only in the declaration or constructor. [ImmutableField]
BruteCollinearPoints.java:44: The private instance (or static) variable 'slopeToOrigin' can be made 'final'; it is initialized only in the declaration or constructor. [ImmutableField]
FastCollinearPoints.java:17: The private instance (or static) variable 'points' can be made 'final'; it is initialized only in the declaration or constructor. [ImmutableField]
FastCollinearPoints.java:19: The user-supplied array 'points' is stored directly. [ArrayIsStoredDirectly]
FastCollinearPoints.java:39: The private instance (or static) variable 'origin' can be made 'final'; it is initialized only in the declaration or constructor. [ImmutableField]
FastCollinearPoints.java:40: The private instance (or static) variable 'point' can be made 'final'; it is initialized only in the declaration or constructor. [ImmutableField]
FastCollinearPoints.java:41: The private instance (or static) variable 'slopeToOrigin' can be made 'final'; it is initialized only in the declaration or constructor. [ImmutableField]
Point.java:135: Avoid unused local variables, such as 'compareResult'. [UnusedLocalVariable]
Point.java:136: Avoid unused local variables, such as 'slopeResult'. [UnusedLocalVariable]
Point.java:137: Avoid unused local variables, such as 'comparator'. [UnusedLocalVariable]
PMD ends with 13 warnings.


================================================================


% checkstyle *.java
*-----------------------------------------------------------

% custom checkstyle checks for Point.java
*-----------------------------------------------------------

% custom checkstyle checks for BruteCollinearPoints.java
*-----------------------------------------------------------
[WARN] BruteCollinearPoints.java:15:1: Defining a nested class in this program suggests poor design. [Design]
Checkstyle ends with 0 errors and 1 warning.

% custom checkstyle checks for FastCollinearPoints.java
*-----------------------------------------------------------
[WARN] FastCollinearPoints.java:15:1: Defining a nested class in this program suggests poor design. [Design]
Checkstyle ends with 0 errors and 1 warning.


================================================================


********************************************************************************
*  TESTING CORRECTNESS
********************************************************************************

Testing correctness of Point
*-----------------------------------------------------------
Running 3 total tests.

Test 1: p.slopeTo(q)
  * positive infinite slope, where p and q have coordinates in [0, 500)
  * positive infinite slope, where p and q have coordinates in [0, 32768)
  * negative infinite slope, where p and q have coordinates in [0, 500)
  * negative infinite slope, where p and q have coordinates in [0, 32768)
  * positive zero     slope, where p and q have coordinates in [0, 500)
  * positive zero     slope, where p and q have coordinates in [0, 32768)
  * symmetric for random points p and q with coordinates in [0, 500)
  * symmetric for random points p and q with coordinates in [0, 32768)
  * transitive for random points p, q, and r with coordinates in [0, 500)
  * transitive for random points p, q, and r with coordinates in [0, 32768)
  * slopeTo(), where p and q have coordinates in [0, 500)
  * slopeTo(), where p and q have coordinates in [0, 32768)
  * slopeTo(), where p and q have coordinates in [0, 10)
  * throw a java.lang.NullPointerException if argument is null
==> passed

Test 2: p.compareTo(q)
  * reflexive, where p and q have coordinates in [0, 500)
  * reflexive, where p and q have coordinates in [0, 32768)
  * antisymmetric, where p and q have coordinates in [0, 500)
  * antisymmetric, where p and q have coordinates in [0, 32768)
  * transitive, where p, q, and r have coordinates in [0, 500)
  * transitive, where p, q, and r have coordinates in [0, 32768)
  * sign of compareTo(), where p and q have coordinates in [0, 500)
  * sign of compareTo(), where p and q have coordinates in [0, 32768)
  * sign of compareTo(), where p and q have coordinates in [0, 10)
  * throw java.lang.NullPointerException exception if argument is null
==> passed

Test 3: p.slopeOrder().compare(q, r)
  * reflexive, where p and q have coordinates in [0, 500)
  * reflexive, where p and q have coordinates in [0, 32768)
  * antisymmetric, where p, q, and r have coordinates in [0, 500)
  * antisymmetric, where p, q, and r have coordinates in [0, 32768)
  * transitive, where p, q, r, and s have coordinates in [0, 500)
  * transitive, where p, q, r, and s have coordinates in [0, 32768)
  * sign of compare(), where p, q, and r have coordinates in [0, 500)
  * sign of compare(), where p, q, and r have coordinates in [0, 32768)
  * sign of compare(), where p, q, and r have coordinates in [0, 10)
  * throw java.lang.NullPointerException if either argument is null
==> passed


Total: 3/3 tests passed!


================================================================
********************************************************************************
*  TESTING CORRECTNESS (substituting reference Point and LineSegment)
********************************************************************************

Testing correctness of BruteCollinearPoints
*-----------------------------------------------------------
Running 17 total tests.

The inputs satisfy the following conditions:
  - no duplicate points
  - no 5 (or more) points are collinear
  - all x- and y-coordinates between 0 and 32,767

Test 1: points from a file
  * filename = input8.txt
    - student segments() returns null

  * filename = equidistant.txt
    - student segments() returns null

  * filename = input40.txt
    - student segments() returns null

  * filename = input48.txt
    - student segments() returns null

==> FAILED

Test 2a: points from a file with horizontal line segments
  * filename = horizontal5.txt
    - student segments() returns null

  * filename = horizontal25.txt
    - student segments() returns null

==> FAILED

Test 2b: random horizontal line segments
  *  1 random horizontal line segment
  *  5 random horizontal line segments
    - student segments() returns null

    - failed on trial 1 of 250
     20
     11927 15947
     15469  3397
      1261  6945
      1285 15947
     18999 15947
      8015 14707
     19749 15947
      5734 14156
      2852 14156
     14283 14156
     13256 14707
     17512  6945
      4096  3397
      7690 14707
      4701  6945
      3148  6945
     17789 14707
      7669  3397
      5577  3397
      8337 14156

  * 10 random horizontal line segments
    - student segments() returns null

    - failed on trial 1 of 50

  * 15 random horizontal line segments
    - student segments() returns null

    - failed on trial 1 of 5

==> FAILED

Test 3a: points from a file with vertical line segments
  * filename = vertical5.txt
    - student segments() returns null

  * filename = vertical25.txt
    - student segments() returns null

==> FAILED

Test 3b: random vertical line segments
  *  1 random vertical line segment
  *  5 random vertical line segments
    - student segments() returns null

    - failed on trial 1 of 250
     20
     14685 15672
     17563  3467
     17563  2338
      7334 18209
      8973 16779
     14244  8531
     14685 18379
      8973  3052
     14244 20779
      7334 15493
     17563  9418
      7334 20984
     14685  7596
     17563 17318
     14685 14896
      8973  2224
     14244 12647
      7334 19334
      8973 12423
     14244  1880

  * 10 random vertical line segments
    - student segments() returns null

    - failed on trial 1 of 50

  * 15 random vertical line segments
    - student segments() returns null

    - failed on trial 1 of 5

==> FAILED

Test 4a: points from a file with no line segments
  * filename = random23.txt
    - student segments() returns null
    - it should return an array of length 0

  * filename = random38.txt
    - student segments() returns null
    - it should return an array of length 0

==> FAILED

Test 4b: random points with no line segments
  *  5 random points
    - student segments() returns null
    - it should return an array of length 0

    - failed on trial 1 of 500
     5
     27157  6194
     26621  6717
     13191 22899
     25950 30947
     29611  1801

  * 10 random points
    - student segments() returns null
    - it should return an array of length 0

    - failed on trial 1 of 250
     10
     18998 16217
      7047 11938
     16434 31204
     18718 18099
      6626 29428
     26947 32068
      2566  5951
     25670  5074
     22729 13126
     21406  5998

  * 20 random points
    - student segments() returns null
    - it should return an array of length 0

    - failed on trial 1 of 100
     20
     24271  5212
     16271 14982
     13672 21035
     25928 10708
     29904 32550
      2032 31864
      9644 31863
     10018  6284
     19329  4626
       395  2080
     29446  4060
     16352   732
     10944 24692
     11842 29605
     21696  8381
     21203 22887
     12862 15630
     20273 18482
     10798  6081
     26601  6958

  * 50 random points
    - student segments() returns null
    - it should return an array of length 0

    - failed on trial 1 of 10

==> FAILED

Test 5: points from a file with fewer than 4 points
  * filename = input1.txt
    - student segments() returns null
    - it should return an array of length 0

  * filename = input2.txt
    - student segments() returns null
    - it should return an array of length 0

  * filename = input3.txt
    - student segments() returns null
    - it should return an array of length 0

==> FAILED

Test 6: check for dependence on either compareTo() or compare()
        returning { -1, +1, 0 } instead of { negative integer,
        positive integer, zero }
  * filename = equidistant.txt
    - student segments() returns null

  * filename = input40.txt
    - student segments() returns null

  * filename = input48.txt
    - student segments() returns null

==> FAILED

Test 7: check for fragile dependence on return value of toString()
  * filename = equidistant.txt
    - student segments() returns null

  * filename = input40.txt
    - student segments() returns null

  * filename = input48.txt
    - student segments() returns null


It is bad style to write code that depends on the particular format of
the output from the toString() method, especially if your reason for
doing so is to circumvent the public API (which intentionally does not
provide access to the x- and y-coordinates).

==> FAILED

Test 8: random line segments, none vertical or horizontal
  *  1 random line segment
  *  5 random line segments
    - student segments() returns null

    - failed on trial 1 of 250
     20
      7009  6691
      8033 10557
      7049 12611
      7936 11146
      5960  1266
      2167  9017
     12223  6825
      7328  8106
      7059 14091
      6042 12977
     11664  1976
       910  8687
     11492   484
     14737 12317
     12094  5706
       993 10223
      7019  8171
      8418 14273
      2478 11033
      7176  7346

  * 10 random line segments
    - student segments() returns null

    - failed on trial 1 of 100

  * 15 random line segments
    - student segments() returns null

    - failed on trial 1 of 50

==> FAILED

Test 9: random line segments
  *  1 random line segment
  *  5 random line segments
    - student segments() returns null

    - failed on trial 1 of 250
     20
     12536 10345
      2866  5936
      9593  5913
      4494  7934
      3746  7016
      3570  6800
      3162  5649
      8459  5571
      2502  5059
     10037  5602
      5208  7478
     12907  2987
     12907  1699
      8126  1975
     12907  6291
     12585 10438
      8270  5514
      3822  6239
      9404  5856
     12907  5115

  * 10 random line segments
    - student segments() returns null

    - failed on trial 1 of 100

  * 15 random line segments
    - student segments() returns null

    - failed on trial 1 of 50

==> FAILED

Test 10: check that data type is immutable by testing whether each method
         returns the same value, regardless of any intervening operations
  * input8.txt

    java.lang.NullPointerException

    TestBruteCollinearPoints.testImmutable(TestBruteCollinearPoints.java:461)
    TestBruteCollinearPoints.testImmutable(TestBruteCollinearPoints.java:516)
    TestBruteCollinearPoints.test10(TestBruteCollinearPoints.java:531)
    TestBruteCollinearPoints.main(TestBruteCollinearPoints.java:753)

    - sequence of operations was:
          BruteCollinearPoints collinear = new BruteCollinearPoints(points);
          collinear.segments()

    - failed on trial 1 of 100

  * equidistant.txt

    java.lang.NullPointerException

    TestBruteCollinearPoints.testImmutable(TestBruteCollinearPoints.java:461)
    TestBruteCollinearPoints.testImmutable(TestBruteCollinearPoints.java:516)
    TestBruteCollinearPoints.test10(TestBruteCollinearPoints.java:532)
    TestBruteCollinearPoints.main(TestBruteCollinearPoints.java:753)

    - sequence of operations was:
          BruteCollinearPoints collinear = new BruteCollinearPoints(points);
          collinear.segments()

    - failed on trial 1 of 100

==> FAILED

Test 11: check that data type does not mutate the constructor argument
  * input8.txt

    java.lang.NullPointerException

    BruteCollinearPoints.numberOfSegments(BruteCollinearPoints.java:38)
    TestBruteCollinearPoints.testMutateConstructorArgument(TestBruteCollinearPoints.java:547)
    TestBruteCollinearPoints.test11(TestBruteCollinearPoints.java:565)
    TestBruteCollinearPoints.main(TestBruteCollinearPoints.java:756)

  * equidistant.txt

    java.lang.NullPointerException

    BruteCollinearPoints.numberOfSegments(BruteCollinearPoints.java:38)
    TestBruteCollinearPoints.testMutateConstructorArgument(TestBruteCollinearPoints.java:547)
    TestBruteCollinearPoints.test11(TestBruteCollinearPoints.java:566)
    TestBruteCollinearPoints.main(TestBruteCollinearPoints.java:756)

==> FAILED

Test 12: numberOfSegments() is consistent with segments()
  * filename = input8.txt

    java.lang.NullPointerException

    BruteCollinearPoints.numberOfSegments(BruteCollinearPoints.java:38)
    TestBruteCollinearPoints.testNumberOfSegments(TestBruteCollinearPoints.java:575)
    TestBruteCollinearPoints.fileNumberOfSegments(TestBruteCollinearPoints.java:599)
    TestBruteCollinearPoints.test12(TestBruteCollinearPoints.java:604)
    TestBruteCollinearPoints.main(TestBruteCollinearPoints.java:759)

  * filename = equidistant.txt

    java.lang.NullPointerException

    BruteCollinearPoints.numberOfSegments(BruteCollinearPoints.java:38)
    TestBruteCollinearPoints.testNumberOfSegments(TestBruteCollinearPoints.java:575)
    TestBruteCollinearPoints.fileNumberOfSegments(TestBruteCollinearPoints.java:599)
    TestBruteCollinearPoints.test12(TestBruteCollinearPoints.java:605)
    TestBruteCollinearPoints.main(TestBruteCollinearPoints.java:759)

  * filename = input40.txt

    java.lang.NullPointerException

    BruteCollinearPoints.numberOfSegments(BruteCollinearPoints.java:38)
    TestBruteCollinearPoints.testNumberOfSegments(TestBruteCollinearPoints.java:575)
    TestBruteCollinearPoints.fileNumberOfSegments(TestBruteCollinearPoints.java:599)
    TestBruteCollinearPoints.test12(TestBruteCollinearPoints.java:606)
    TestBruteCollinearPoints.main(TestBruteCollinearPoints.java:759)

  * filename = input48.txt

    java.lang.NullPointerException

    BruteCollinearPoints.numberOfSegments(BruteCollinearPoints.java:38)
    TestBruteCollinearPoints.testNumberOfSegments(TestBruteCollinearPoints.java:575)
    TestBruteCollinearPoints.fileNumberOfSegments(TestBruteCollinearPoints.java:599)
    TestBruteCollinearPoints.test12(TestBruteCollinearPoints.java:607)
    TestBruteCollinearPoints.main(TestBruteCollinearPoints.java:759)

  * filename = horizontal5.txt

    java.lang.NullPointerException

    BruteCollinearPoints.numberOfSegments(BruteCollinearPoints.java:38)
    TestBruteCollinearPoints.testNumberOfSegments(TestBruteCollinearPoints.java:575)
    TestBruteCollinearPoints.fileNumberOfSegments(TestBruteCollinearPoints.java:599)
    TestBruteCollinearPoints.test12(TestBruteCollinearPoints.java:608)
    TestBruteCollinearPoints.main(TestBruteCollinearPoints.java:759)

  * filename = vertical5.txt

    java.lang.NullPointerException

    BruteCollinearPoints.numberOfSegments(BruteCollinearPoints.java:38)
    TestBruteCollinearPoints.testNumberOfSegments(TestBruteCollinearPoints.java:575)
    TestBruteCollinearPoints.fileNumberOfSegments(TestBruteCollinearPoints.java:599)
    TestBruteCollinearPoints.test12(TestBruteCollinearPoints.java:609)
    TestBruteCollinearPoints.main(TestBruteCollinearPoints.java:759)

  * filename = random23.txt

    java.lang.NullPointerException

    BruteCollinearPoints.numberOfSegments(BruteCollinearPoints.java:38)
    TestBruteCollinearPoints.testNumberOfSegments(TestBruteCollinearPoints.java:575)
    TestBruteCollinearPoints.fileNumberOfSegments(TestBruteCollinearPoints.java:599)
    TestBruteCollinearPoints.test12(TestBruteCollinearPoints.java:610)
    TestBruteCollinearPoints.main(TestBruteCollinearPoints.java:759)

==> FAILED

Test 13: throws an exception if either the constructor argument is null
         or any entry in array is null
  * argument is null
    - constructor throws wrong exception
    - constructor throws a java.lang.NullPointerException
    - constructor should throw a java.lang.IllegalArgumentException
     0

  * Point[] of length 10, number of null entries = 1
  * Point[] of length 10, number of null entries = 10
  * Point[] of length 4, number of null entries = 1
  * Point[] of length 3, number of null entries = 1
  * Point[] of length 2, number of null entries = 1
    - constructor throws wrong exception
    - constructor throws a java.lang.NullPointerException
    - constructor should throw a java.lang.IllegalArgumentException
     2
     null
     15548 19088

  * Point[] of length 1, number of null entries = 1
    - constructor fails to throw an exception
     1
     null

==> FAILED

Test 14: check that the constructor throws an exception if duplicate points
  * 50 points
  * 25 points
  * 5 points
  * 4 points
  * 3 points
  * 2 points
==> passed


Total: 1/17 tests passed!


================================================================
Testing correctness of FastCollinearPoints
*-----------------------------------------------------------
Running 21 total tests.

The inputs satisfy the following conditions:
  - no duplicate points
  - all x- and y-coordinates between 0 and 32,767

Test 1: points from a file
  * filename = input8.txt
  * filename = equidistant.txt
    - segments() contains the same segment more than once
    - segment 1: (10000, 0) -> (0, 30000)
    - segment 3: (10000, 0) -> (0, 30000)

    - number of entries in student   solution: 4
    - number of entries in reference solution: 4
    - 4 extra entries in student solution, including:
      '(18000, 2000) -> (2000, 18000)'

    - 4 missing entries in student solution, including:
      '(30000, 0) -> (20000, 10000) -> (10000, 20000) -> (0, 30000)'


  * filename = input40.txt
    - segments() contains the same segment more than once
    - segment 13: (26000, 8000) -> (1000, 31000)
    - segment 15: (26000, 8000) -> (1000, 31000)

    - number of entries in student   solution: 42
    - number of entries in reference solution: 4
    - 42 extra entries in student solution, including:
      '(22000, 29000) -> (10000, 31000)'

    - 4 missing entries in student solution, including:
      '(2000, 29000) -> (4000, 29000) -> (22000, 29000) -> (28000, 29000)'


  * filename = input48.txt
    - segments() contains the same segment more than once
    - segment 10: (18000, 13000) -> (23000, 29000)
    - segment 20: (18000, 13000) -> (23000, 29000)

    - number of entries in student   solution: 69
    - number of entries in reference solution: 6
    - 69 extra entries in student solution, including:
      '(5000, 29000) -> (17000, 31000)'

    - 6 missing entries in student solution, including:
      '(1000, 26000) -> (9000, 26000) -> (11000, 26000) -> (18000, 26000)'


  * filename = input299.txt
    - segments() contains the same segment more than once
    - segment 58: (29050, 5250) -> (16900, 32700)
    - segment 200: (29050, 5250) -> (16900, 32700)

    - number of entries in student   solution: 534
    - number of entries in reference solution: 6
    - 534 extra entries in student solution, including:
      '(600, 31900) -> (1000, 32650)'

    - 6 missing entries in student solution, including:
      '(3250, 17450) -> (8500, 17450) -> (13400, 17450) -> (17250, 17450)'


==> FAILED

Test 2a: points from a file with horizontal line segments
  * filename = horizontal5.txt
    - number of entries in student   solution: 1
    - number of entries in reference solution: 5
    - 1 extra entry in student solution:
      '(5766, 4652) -> (7821, 14118)'

    - 5 missing entries in student solution, including:
      '(2682, 14118) -> (5067, 14118) -> (7453, 14118) -> (7821, 14118)'


  * filename = horizontal25.txt
    - number of entries in student   solution: 1
    - number of entries in reference solution: 25
    - 1 extra entry in student solution:
      '(10021, 1256) -> (19666, 20913)'

    - 25 missing entries in student solution, including:
      '(8784, 20913) -> (9880, 20913) -> (16352, 20913) -> (19666, 20913)'


  * filename = horizontal50.txt
    - number of entries in student   solution: 1
    - number of entries in reference solution: 50
    - 1 extra entry in student solution:
      '(2624, 1040) -> (17428, 20754)'

    - 50 missing entries in student solution, including:
      '(5249, 20754) -> (5559, 20754) -> (14800, 20754) -> (17428, 20754)'


  * filename = horizontal75.txt
    - number of entries in student   solution: 2
    - number of entries in reference solution: 75
    - 2 extra entries in student solution, including:
      '(14707, 6016) -> (13795, 12628)'

    - 75 missing entries in student solution, including:
      '(1536, 20976) -> (6545, 20976) -> (14178, 20976) -> (14591, 20976)'


  * filename = horizontal100.txt
    - number of entries in student   solution: 2
    - number of entries in reference solution: 100
    - 2 extra entries in student solution, including:
      '(1672, 13404) -> (2656, 14586)'

    - 100 missing entries in student solution, including:
      '(5835, 20698) -> (7673, 20698) -> (16154, 20698) -> (19642, 20698)'


==> FAILED

Test 2b: random horizontal line segments
  *  1 random horizontal line segment
  *  5 random horizontal line segments
    - number of entries in student   solution: 1
    - number of entries in reference solution: 5
    - 1 extra entry in student solution:
      '(9130, 1721) -> (19556, 12598)'

    - 5 missing entries in student solution, including:
      '(2125, 12598) -> (17649, 12598) -> (18989, 12598) -> (19556, 12598)'


    - failed on trial 1 of 250
     20
     17649 12598
      9130  1721
      2125 12598
     14097  1721
     15138  7629
     17057  7629
     19556 12598
     19886  7629
     16112 11963
     17784  7629
      2159  4445
     20160  1721
     11562 11963
      4352  4445
     20930 11963
     18989 12598
     16630  4445
     12493  1721
      8798 11963
      4155  4445

  * 10 random horizontal line segments
    - number of entries in student   solution: 1
    - number of entries in reference solution: 10
    - 1 extra entry in student solution:
      '(10525, 1462) -> (17845, 20076)'

    - 10 missing entries in student solution, including:
      '(3653, 20076) -> (7760, 20076) -> (9328, 20076) -> (17845, 20076)'


    - failed on trial 1 of 50

  * 15 random horizontal line segments
    - number of entries in student   solution: 1
    - number of entries in reference solution: 15
    - 1 extra entry in student solution:
      '(5773, 1770) -> (15120, 19204)'

    - 15 missing entries in student solution, including:
      '(9907, 19204) -> (13773, 19204) -> (13933, 19204) -> (15120, 19204)'


    - failed on trial 1 of 5

==> FAILED

Test 3a: points from a file with vertical line segments
  * filename = vertical5.txt
    - number of entries in student   solution: 1
    - number of entries in reference solution: 5
    - 1 extra entry in student solution:
      '(8421, 1829) -> (5757, 20856)'

    - 5 missing entries in student solution, including:
      '(14407, 10367) -> (14407, 17188) -> (14407, 17831) -> (14407, 19953)'


  * filename = vertical25.txt
    - number of entries in student   solution: 1
    - number of entries in reference solution: 25
    - 1 extra entry in student solution:
      '(9557, 1388) -> (13536, 20946)'

    - 25 missing entries in student solution, including:
      '(19953, 10489) -> (19953, 10688) -> (19953, 19299) -> (19953, 20439)'


  * filename = vertical50.txt
    - number of entries in student   solution: 1
    - number of entries in reference solution: 50
    - 1 extra entry in student solution:
      '(10209, 1143) -> (10695, 20927)'

    - 50 missing entries in student solution, including:
      '(5991, 15606) -> (5991, 20227) -> (5991, 20340) -> (5991, 20424)'


  * filename = vertical75.txt
    - number of entries in student   solution: 1
    - number of entries in reference solution: 75
    - 1 extra entry in student solution:
      '(9632, 1012) -> (18293, 20983)'

    - 75 missing entries in student solution, including:
      '(13780, 16365) -> (13780, 17494) -> (13780, 18253) -> (13780, 18908)'


  * filename = vertical100.txt
    - number of entries in student   solution: 2
    - number of entries in reference solution: 100
    - 2 extra entries in student solution, including:
      '(2977, 15792) -> (18009, 18793)'

    - 100 missing entries in student solution, including:
      '(15135, 15588) -> (15135, 17398) -> (15135, 19476) -> (15135, 20439)'


==> FAILED

Test 3b: random vertical line segments
  *  1 random vertical line segment
  *  5 random vertical line segments
    - number of entries in student   solution: 1
    - number of entries in reference solution: 5
    - 1 extra entry in student solution:
      '(12053, 1721) -> (10128, 20626)'

    - 5 missing entries in student solution, including:
      '(4466, 5170) -> (4466, 12319) -> (4466, 12926) -> (4466, 14386)'


    - failed on trial 1 of 250
     20
     12053  3541
     10128 18524
      4466 12926
      4466 14386
     12101  3435
     16418 19811
     10128 18228
     12101 14364
      4466  5170
     16418 10307
     12101  9595
      4466 12319
     10128 20626
     12101 15858
     12053 14939
     16418  2481
     16418 14965
     10128  4565
     12053  1721
     12053  7275

  * 10 random vertical line segments
    - number of entries in student   solution: 1
    - number of entries in reference solution: 10
    - 1 extra entry in student solution:
      '(1045, 1664) -> (13139, 20829)'

    - 10 missing entries in student solution, including:
      '(11284, 10045) -> (11284, 10379) -> (11284, 12879) -> (11284, 20253)'


    - failed on trial 1 of 50

  * 15 random vertical line segments
    - number of entries in student   solution: 1
    - number of entries in reference solution: 15
    - 1 extra entry in student solution:
      '(16892, 1485) -> (12094, 20122)'

    - 15 missing entries in student solution, including:
      '(12757, 8980) -> (12757, 10158) -> (12757, 12061) -> (12757, 14019)'


    - failed on trial 1 of 5

==> FAILED

Test 4a: points from a file with no line segments
  * filename = random23.txt
  * filename = random38.txt
  * filename = random91.txt
  * filename = random152.txt
==> passed

Test 4b: random points with no line segments
  *  5 random points
  * 10 random points
  * 20 random points
  * 50 random points
==> passed

Test 5a: points from a file with 5 or more on some line segments
  * filename = input9.txt
  * filename = input10.txt
    - segments() contains a subsegment of a segment in reference solution
    - student   segment 0: (23000, 16000) -> (3000, 26000)
    - reference segment 0: (28000, 13500) -> (23000, 16000) -> (13000, 21000) -> (3000, 26000)

    - number of entries in student   solution: 2
    - number of entries in reference solution: 2
    - 1 extra entry in student solution:
      '(23000, 16000) -> (3000, 26000)'

    - 1 missing entry in student solution:
      '(28000, 13500) -> (23000, 16000) -> (13000, 21000) -> (3000, 26000)'


  * filename = input20.txt
    - segments() contains the same segment more than once
    - segment 0: (7168, 25088) -> (7168, 29184)
    - segment 1: (7168, 25088) -> (7168, 29184)

    - number of entries in student   solution: 13
    - number of entries in reference solution: 5
    - 13 extra entries in student solution, including:
      '(8192, 26112) -> (7168, 29184)'

    - 5 missing entries in student solution, including:
      '(4160, 29184) -> (5120, 29184) -> (6144, 29184) -> (7168, 29184) -> (8192, 29184)'


  * filename = input50.txt
    - segments() contains the same segment more than once
    - segment 12: (25000, 1000) -> (9000, 29000)
    - segment 22: (25000, 1000) -> (9000, 29000)

    - number of entries in student   solution: 75
    - number of entries in reference solution: 7
    - 74 extra entries in student solution, including:
      '(5000, 29000) -> (17000, 31000)'

    - 6 missing entries in student solution, including:
      '(1000, 26000) -> (9000, 26000) -> (11000, 26000) -> (18000, 26000)'


  * filename = input80.txt
    - segments() contains the same segment more than once
    - segment 32: (15000, 0) -> (27000, 31000)
    - segment 38: (15000, 0) -> (27000, 31000)

    - segments() contains a subsegment of a segment in reference solution
    - student   segment 63: (25000, 8000) -> (25000, 27000)
    - reference segment 28: (25000, 8000) -> (25000, 9000) -> (25000, 12000) -> (25000, 27000) -> (25000, 29000) -> (25000, 31000)

    - number of entries in student   solution: 250
    - number of entries in reference solution: 31
    - 248 extra entries in student solution, including:
      '(15000, 30000) -> (29000, 31000)'

    - 29 missing entries in student solution, including:
      '(13000, 29000) -> (19000, 29000) -> (25000, 29000) -> (28000, 29000)'


  * filename = input300.txt
    - segments() contains the same segment more than once
    - segment 60: (29050, 5250) -> (16900, 32700)
    - segment 203: (29050, 5250) -> (16900, 32700)

    - number of entries in student   solution: 539
    - number of entries in reference solution: 6
    - 539 extra entries in student solution, including:
      '(600, 31900) -> (1000, 32650)'

    - 6 missing entries in student solution, including:
      '(3250, 17450) -> (8500, 17450) -> (13400, 17450) -> (17250, 17450)'


  * filename = inarow.txt
    - number of entries in student   solution: 6
    - number of entries in reference solution: 5
    - 3 extra entries in student solution, including:
      '(20000, 0) -> (0, 30000)'

    - 2 missing entries in student solution, including:
      '(30000, 0) -> (27000, 7500) -> (26000, 10000) -> (20000, 25000) -> (19000, 27500) -> (18000, 30000)'


==> FAILED

Test 5b: points from a file with 5 or more on some line segments
  * filename = kw1260.txt
    - segments() contains the same segment more than once
    - segment 2: (14820, 5966) -> (14557, 18640)
    - segment 4: (14820, 5966) -> (14557, 18640)

    - number of entries in student   solution: 1446
    - number of entries in reference solution: 288
    - 1355 extra entries in student solution, including:
      '(15574, 30361) -> (14236, 30449)'

    - 197 missing entries in student solution, including:
      '(16384, 30255) -> (15979, 30308) -> (15574, 30361) -> (15169, 30414) -> (14764, 30467)'


  * filename = rs1423.txt
    - segments() contains the same segment more than once
    - segment 52: (12936, 14466) -> (13685, 27948)
    - segment 1413: (12936, 14466) -> (13685, 27948)

    - segments() contains a subsegment of a segment in reference solution
    - student   segment 2: (31442, 1260) -> (31440, 1860)
    - reference segment 1: (31443, 960) -> (31442, 1260) -> (31441, 1560) -> (31440, 1860)

    - number of entries in student   solution: 1446
    - number of entries in reference solution: 443
    - 1285 extra entries in student solution, including:
      '(13927, 27810) -> (13443, 28086)'

    - 282 missing entries in student solution, including:
      '(14169, 27672) -> (13927, 27810) -> (13685, 27948) -> (13443, 28086)'


==> FAILED

Test 6: points from a file with fewer than 4 points
  * filename = input1.txt
  * filename = input2.txt
  * filename = input3.txt
==> passed

Test 7: check for dependence on either compareTo() or compare()
        returning { -1, +1, 0 } instead of { negative integer,
        positive integer, zero }
  * filename = equidistant.txt
    - segments() contains the same segment more than once
    - segment 1: (10000, 0) -> (0, 30000)
    - segment 3: (10000, 0) -> (0, 30000)

    - number of entries in student   solution: 4
    - number of entries in reference solution: 4
    - 4 extra entries in student solution, including:
      '(18000, 2000) -> (2000, 18000)'

    - 4 missing entries in student solution, including:
      '(30000, 0) -> (20000, 10000) -> (10000, 20000) -> (0, 30000)'


  * filename = input40.txt
    - segments() contains the same segment more than once
    - segment 13: (26000, 8000) -> (1000, 31000)
    - segment 15: (26000, 8000) -> (1000, 31000)

    - number of entries in student   solution: 42
    - number of entries in reference solution: 4
    - 42 extra entries in student solution, including:
      '(22000, 29000) -> (10000, 31000)'

    - 4 missing entries in student solution, including:
      '(2000, 29000) -> (4000, 29000) -> (22000, 29000) -> (28000, 29000)'


  * filename = input48.txt
    - segments() contains the same segment more than once
    - segment 10: (18000, 13000) -> (23000, 29000)
    - segment 20: (18000, 13000) -> (23000, 29000)

    - number of entries in student   solution: 69
    - number of entries in reference solution: 6
    - 69 extra entries in student solution, including:
      '(5000, 29000) -> (17000, 31000)'

    - 6 missing entries in student solution, including:
      '(1000, 26000) -> (9000, 26000) -> (11000, 26000) -> (18000, 26000)'


  * filename = input299.txt
    - segments() contains the same segment more than once
    - segment 58: (29050, 5250) -> (16900, 32700)
    - segment 200: (29050, 5250) -> (16900, 32700)

    - number of entries in student   solution: 534
    - number of entries in reference solution: 6
    - 534 extra entries in student solution, including:
      '(600, 31900) -> (1000, 32650)'

    - 6 missing entries in student solution, including:
      '(3250, 17450) -> (8500, 17450) -> (13400, 17450) -> (17250, 17450)'


==> FAILED

Test 8: check for fragile dependence on return value of toString()
  * filename = equidistant.txt
    - segments() contains the same segment more than once
    - segment 1: (10000, 0) -> (0, 30000)
    - segment 3: (10000, 0) -> (0, 30000)

    - number of entries in student   solution: 4
    - number of entries in reference solution: 4
    - 4 extra entries in student solution, including:
      '(18000, 2000) -> (2000, 18000)'

    - 4 missing entries in student solution, including:
      '(30000, 0) -> (20000, 10000) -> (10000, 20000) -> (0, 30000)'


  * filename = input40.txt
    - segments() contains the same segment more than once
    - segment 13: (26000, 8000) -> (1000, 31000)
    - segment 15: (26000, 8000) -> (1000, 31000)

    - number of entries in student   solution: 42
    - number of entries in reference solution: 4
    - 42 extra entries in student solution, including:
      '(22000, 29000) -> (10000, 31000)'

    - 4 missing entries in student solution, including:
      '(2000, 29000) -> (4000, 29000) -> (22000, 29000) -> (28000, 29000)'


  * filename = input48.txt
    - segments() contains the same segment more than once
    - segment 10: (18000, 13000) -> (23000, 29000)
    - segment 20: (18000, 13000) -> (23000, 29000)

    - number of entries in student   solution: 69
    - number of entries in reference solution: 6
    - 69 extra entries in student solution, including:
      '(5000, 29000) -> (17000, 31000)'

    - 6 missing entries in student solution, including:
      '(1000, 26000) -> (9000, 26000) -> (11000, 26000) -> (18000, 26000)'



It is bad style to write code that depends on the particular format of
the output from the toString() method, especially if your reason for
doing so is to circumvent the public API (which intentionally does not
provide access to the x- and y-coordinates).

==> FAILED

Test 9: random line segments, none vertical or horizontal
  *  1 random line segment
  *  5 random line segments
    - segments() contains a subsegment of a segment in reference solution
    - student   segment 1: (10770, 11242) -> (12759, 13939)
    - reference segment 1: (10107, 10343) -> (10770, 11242) -> (12096, 13040) -> (12759, 13939)

    - number of entries in student   solution: 5
    - number of entries in reference solution: 5
    - 4 extra entries in student solution, including:
      '(10770, 11242) -> (12759, 13939)'

    - 4 missing entries in student solution, including:
      '(10107, 10343) -> (10770, 11242) -> (12096, 13040) -> (12759, 13939)'


    - failed on trial 1 of 500
     20
      6367  9501
     10326  5588
     14864 13831
     11762  8636
      8890  2540
      4259 13066
     10770 11242
     12096 13040
      9841  9935
      8698  2978
      5102  5706
      4607  4221
     11492 19984
     12759 13939
     12036 13627
      8531  1778
     10107 10343
      3397   591
      8571  2205
      8501 13372

  * 25 random line segments
    - segments() contains a subsegment of a segment in reference solution
    - student   segment 5: (8867, 8727) -> (12667, 12072)
    - reference segment 5: (3547, 4044) -> (8867, 8727) -> (11907, 11403) -> (12667, 12072)

    - number of entries in student   solution: 25
    - number of entries in reference solution: 25
    - 5 extra entries in student solution, including:
      '(13953, 17614) -> (16285, 21530)'

    - 5 missing entries in student solution, including:
      '(13826, 7950) -> (14696, 9924) -> (15131, 10911) -> (17306, 15846)'


    - failed on trial 1 of 100

  * 50 random line segments
    - segments() contains a subsegment of a segment in reference solution
    - student   segment 0: (7705, 10608) -> (13767, 10811)
    - reference segment 0: (777, 10376) -> (7705, 10608) -> (11169, 10724) -> (13767, 10811)

    - number of entries in student   solution: 50
    - number of entries in reference solution: 50
    - 12 extra entries in student solution, including:
      '(6650, 13986) -> (7530, 18146)'

    - 12 missing entries in student solution, including:
      '(2502, 13314) -> (5390, 13930) -> (6473, 14161) -> (7917, 14469)'


    - failed on trial 1 of 15

  * 100 random line segments
    - segments() contains a subsegment of a segment in reference solution
    - student   segment 2: (4434, 14616) -> (8706, 14680)
    - reference segment 1: (1764, 14576) -> (4434, 14616) -> (8439, 14676) -> (8706, 14680)

    - number of entries in student   solution: 103
    - number of entries in reference solution: 100
    - 27 extra entries in student solution, including:
      '(13169, 17355) -> (13877, 20931)'

    - 24 missing entries in student solution, including:
      '(1764, 14576) -> (4434, 14616) -> (8439, 14676) -> (8706, 14680)'


    - failed on trial 1 of 2

==> FAILED

Test 10: random line segments
  *  1 random line segment
  *  5 random line segments
    - segments() contains a subsegment of a segment in reference solution
    - student   segment 1: (1629, 7845) -> (6053, 12437)
    - reference segment 1: (839, 7025) -> (1629, 7845) -> (3683, 9977) -> (6053, 12437)

    - number of entries in student   solution: 5
    - number of entries in reference solution: 5
    - 3 extra entries in student solution, including:
      '(1629, 7845) -> (6053, 12437)'

    - 3 missing entries in student solution, including:
      '(839, 7025) -> (1629, 7845) -> (3683, 9977) -> (6053, 12437)'


    - failed on trial 1 of 500
     20
      7708  3838
      2825 13588
     13546  5204
      5513 13588
      6074 10888
     13558  5380
      7708  5266
      6053 12437
      7708  5434
      7708  3586
      4169 13588
     13585  5776
      3683  9977
      6004 10013
      5950  9338
      6089 13588
      1629  7845
       839  7025
      6050 10588
     13462  3972

  * 25 random line segments
    - segments() contains a subsegment of a segment in reference solution
    - student   segment 0: (8574, 6379) -> (9195, 6460)
    - reference segment 0: (7723, 6268) -> (8574, 6379) -> (9126, 6451) -> (9195, 6460)

    - number of entries in student   solution: 25
    - number of entries in reference solution: 25
    - 11 extra entries in student solution, including:
      '(14221, 14466) -> (14441, 14506)'

    - 11 missing entries in student solution, including:
      '(13561, 14346) -> (14221, 14466) -> (14320, 14484) -> (14441, 14506)'


    - failed on trial 1 of 100

  * 50 random line segments
    - segments() contains a subsegment of a segment in reference solution
    - student   segment 7: (8911, 6834) -> (10288, 7266)
    - reference segment 11: (7534, 6402) -> (8911, 6834) -> (9166, 6914) -> (10288, 7266)

    - number of entries in student   solution: 37
    - number of entries in reference solution: 50
    - 13 extra entries in student solution, including:
      '(7520, 12314) -> (9270, 13464)'

    - 26 missing entries in student solution, including:
      '(1421, 13812) -> (2033, 13812) -> (4889, 13812) -> (5297, 13812)'


    - failed on trial 1 of 15

  * 100 random line segments
    - segments() contains a subsegment of a segment in reference solution
    - student   segment 2: (6312, 5291) -> (11352, 5543)
    - reference segment 10: (6132, 5282) -> (6312, 5291) -> (11052, 5528) -> (11352, 5543)

    - number of entries in student   solution: 83
    - number of entries in reference solution: 100
    - 42 extra entries in student solution, including:
      '(8961, 13230) -> (12516, 14175)'

    - 59 missing entries in student solution, including:
      '(12240, 13760) -> (13590, 13760) -> (13725, 13760) -> (13887, 13760)'


    - failed on trial 1 of 2

==> FAILED

Test 11: random distinct points in a given range
  * 5 random points in a 10-by-10 grid
    - segments() contains a subsegment of a segment in reference solution
    - student   segment 0: (9, 2) -> (9, 9)
    - reference segment 0: (9, 1) -> (9, 2) -> (9, 7) -> (9, 9)

    - number of entries in student   solution: 1
    - number of entries in reference solution: 1
    - 1 extra entry in student solution:
      '(9, 2) -> (9, 9)'

    - 1 missing entry in student solution:
      '(9, 1) -> (9, 2) -> (9, 7) -> (9, 9)'


    - failed on trial 226 of 500
     5
         9     7
         1     8
         9     9
         9     2
         9     1

  * 10 random points in a 10-by-10 grid
    - number of entries in student   solution: 2
    - number of entries in reference solution: 0
    - 2 extra entries in student solution, including:
      '(0, 3) -> (9, 9)'


    - failed on trial 1 of 500
     10
         5     5
         0     1
         0     3
         7     2
         8     5
         5     1
         3     1
         0     8
         6     3
         9     9

  * 50 random points in a 10-by-10 grid
    - segments() contains the same segment more than once
    - segment 0: (2, 0) -> (4, 9)
    - segment 2: (2, 0) -> (4, 9)

    - segments() contains a subsegment of a segment in reference solution
    - student   segment 11: (8, 2) -> (5, 8)
    - reference segment 2: (9, 0) -> (8, 2) -> (7, 4) -> (5, 8)

    - number of entries in student   solution: 65
    - number of entries in reference solution: 46
    - 60 extra entries in student solution, including:
      '(8, 6) -> (0, 9)'

    - 41 missing entries in student solution, including:
      '(0, 9) -> (4, 9) -> (8, 9) -> (9, 9)'


    - failed on trial 1 of 100

  * 90 random points in a 10-by-10 grid
    - segments() contains the same segment more than once
    - segment 1: (4, 0) -> (7, 9)
    - segment 2: (4, 0) -> (7, 9)

    - segments() contains a subsegment of a segment in reference solution
    - student   segment 47: (8, 2) -> (1, 9)
    - reference segment 31: (9, 1) -> (8, 2) -> (7, 3) -> (6, 4) -> (5, 5) -> (4, 6) -> (3, 7) -> (2, 8) -> (1, 9)

    - number of entries in student   solution: 102
    - number of entries in reference solution: 138
    - 92 extra entries in student solution, including:
      '(9, 4) -> (0, 8)'

    - 128 missing entries in student solution, including:
      '(1, 9) -> (2, 9) -> (3, 9) -> (5, 9) -> (6, 9) -> (7, 9) -> (9, 9)'


    - failed on trial 1 of 50

  * 200 random points in a 50-by-50 grid
    - segments() contains the same segment more than once
    - segment 13: (45, 1) -> (12, 49)
    - segment 21: (45, 1) -> (12, 49)

    - segments() contains a subsegment of a segment in reference solution
    - student   segment 38: (8, 4) -> (29, 46)
    - reference segment 183: (6, 0) -> (8, 4) -> (10, 8) -> (22, 32) -> (29, 46) -> (30, 48)

    - number of entries in student   solution: 1330
    - number of entries in reference solution: 231
    - 1314 extra entries in student solution, including:
      '(1, 45) -> (30, 48)'

    - 215 missing entries in student solution, including:
      '(7, 47) -> (21, 47) -> (23, 47) -> (48, 47)'


    - failed on trial 1 of 10

==> FAILED

Test 12: m*n points on an m-by-n grid
  * 3-by-3 grid
    - segments() contains the same segment more than once
    - segment 2: (0, 0) -> (2, 2)
    - segment 3: (0, 0) -> (2, 2)

    - number of entries in student   solution: 4
    - number of entries in reference solution: 0
    - 4 extra entries in student solution, including:
      '(0, 1) -> (2, 2)'


  * 4-by-4 grid
    - segments() contains the same segment more than once
    - segment 0: (3, 0) -> (2, 3)
    - segment 1: (3, 0) -> (2, 3)

    - segments() contains a subsegment of a segment in reference solution
    - student   segment 4: (1, 1) -> (3, 3)
    - reference segment 5: (0, 0) -> (1, 1) -> (2, 2) -> (3, 3)

    - number of entries in student   solution: 8
    - number of entries in reference solution: 10
    - 7 extra entries in student solution, including:
      '(3, 1) -> (1, 3)'

    - 9 missing entries in student solution, including:
      '(0, 3) -> (1, 3) -> (2, 3) -> (3, 3)'


  * 5-by-5 grid
    - segments() contains the same segment more than once
    - segment 0: (1, 0) -> (3, 4)
    - segment 1: (1, 0) -> (3, 4)

    - segments() contains a subsegment of a segment in reference solution
    - student   segment 3: (2, 1) -> (2, 4)
    - reference segment 13: (2, 0) -> (2, 1) -> (2, 2) -> (2, 3) -> (2, 4)

    - number of entries in student   solution: 20
    - number of entries in reference solution: 16
    - 18 extra entries in student solution, including:
      '(4, 3) -> (0, 4)'

    - 14 missing entries in student solution, including:
      '(0, 4) -> (1, 4) -> (2, 4) -> (3, 4) -> (4, 4)'


  * 10-by-10 grid
    - segments() contains the same segment more than once
    - segment 0: (1, 0) -> (8, 9)
    - segment 2: (1, 0) -> (8, 9)

    - segments() contains a subsegment of a segment in reference solution
    - student   segment 53: (1, 1) -> (9, 9)
    - reference segment 110: (0, 0) -> (1, 1) -> (2, 2) -> (3, 3) -> (4, 4) -> (5, 5) -> (6, 6) -> (7, 7) -> (8, 8) -> (9, 9)

    - number of entries in student   solution: 104
    - number of entries in reference solution: 154
    - 92 extra entries in student solution, including:
      '(9, 3) -> (0, 9)'

    - 142 missing entries in student solution, including:
      '(0, 9) -> (1, 9) -> (2, 9) -> (3, 9) -> (4, 9) -> (5, 9) -> (6, 9) -> (7, 9) -> (8, 9) -> (9, 9)'


  * 20-by-20 grid
    - segments() contains the same segment more than once
    - segment 0: (1, 0) -> (18, 19)
    - segment 1: (1, 0) -> (18, 19)

    - number of entries in student   solution: 472
    - number of entries in reference solution: 2446
    - 466 extra entries in student solution, including:
      '(19, 3) -> (0, 19)'

    - 2440 missing entries in student solution, including:
      '(0, 19) -> (1, 19) -> (2, 19) -> (3, 19) -> (4, 19) -> (5, 19) -> (6, 19) -> (7, 19) -> (8, 19) -> (9, 19) -> (10, 19) -> (11, 19) -> (12, 19) -> (13, 19) -> (14, 19) -> (15, 19) -> (16, 19) -> (17, 19) -> (18, 19) -> (19, 19)'


  * 5-by-4 grid
    - segments() contains the same segment more than once
    - segment 0: (3, 0) -> (3, 3)
    - segment 1: (3, 0) -> (3, 3)

    - segments() contains a subsegment of a segment in reference solution
    - student   segment 5: (3, 1) -> (1, 3)
    - reference segment 1: (4, 0) -> (3, 1) -> (2, 2) -> (1, 3)

    - number of entries in student   solution: 14
    - number of entries in reference solution: 13
    - 13 extra entries in student solution, including:
      '(4, 1) -> (1, 3)'

    - 12 missing entries in student solution, including:
      '(0, 3) -> (1, 3) -> (2, 3) -> (3, 3) -> (4, 3)'


  * 6-by-4 grid
    - segments() contains the same segment more than once
    - segment 4: (3, 1) -> (2, 3)
    - segment 6: (3, 1) -> (2, 3)

    - number of entries in student   solution: 18
    - number of entries in reference solution: 16
    - 15 extra entries in student solution, including:
      '(5, 1) -> (1, 3)'

    - 13 missing entries in student solution, including:
      '(0, 3) -> (1, 3) -> (2, 3) -> (3, 3) -> (4, 3) -> (5, 3)'


  * 10-by-4 grid
    - segments() contains the same segment more than once
    - segment 0: (1, 0) -> (8, 3)
    - segment 1: (1, 0) -> (8, 3)

    - number of entries in student   solution: 34
    - number of entries in reference solution: 38
    - 30 extra entries in student solution, including:
      '(8, 1) -> (1, 3)'

    - 34 missing entries in student solution, including:
      '(0, 3) -> (1, 3) -> (2, 3) -> (3, 3) -> (4, 3) -> (5, 3) -> (6, 3) -> (7, 3) -> (8, 3) -> (9, 3)'


  * 15-by-4 grid
    - segments() contains the same segment more than once
    - segment 0: (1, 0) -> (13, 3)
    - segment 3: (1, 0) -> (13, 3)

    - number of entries in student   solution: 58
    - number of entries in reference solution: 79
    - 50 extra entries in student solution, including:
      '(14, 1) -> (1, 3)'

    - 71 missing entries in student solution, including:
      '(0, 3) -> (1, 3) -> (2, 3) -> (3, 3) -> (4, 3) -> (5, 3) -> (6, 3) -> (7, 3) -> (8, 3) -> (9, 3) -> (10, 3) -> (11, 3) -> (12, 3) -> (13, 3) -> (14, 3)'


  * 25-by-4 grid
    - segments() contains the same segment more than once
    - segment 1: (3, 0) -> (23, 3)
    - segment 3: (3, 0) -> (23, 3)

    - number of entries in student   solution: 100
    - number of entries in reference solution: 213
    - 86 extra entries in student solution, including:
      '(24, 1) -> (1, 3)'

    - 199 missing entries in student solution, including:
      '(0, 3) -> (1, 3) -> (2, 3) -> (3, 3) -> (4, 3) -> (5, 3) -> (6, 3) -> (7, 3) -> (8, 3) -> (9, 3) -> (10, 3) -> (11, 3) -> (12, 3) -> (13, 3) -> (14, 3) -> (15, 3) -> (16, 3) -> (17, 3) -> (18, 3) -> (19, 3) -> (20, 3) -> (21, 3) -> (22, 3) -> (23, 3) -> (24, 3)'


==> FAILED

Test 13: check that data type is immutable by testing whether each method
         returns the same value, regardless of any intervening operations
  * input8.txt
    - failed after 4 operations involving FastCollinearPoints
    - first and last call to se

...

WARNING: the grading output was truncated due to excessive length.
Typically, this is because you have a method that has an unanticipated side effect
(such as printing to standard output or throwing an exception). A large amount of output
can also arise from failing many tests.
