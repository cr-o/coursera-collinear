See the Assessment Guide for information on how to interpret this report.

ASSESSMENT SUMMARY

Compilation:  PASSED
API:          PASSED

Spotbugs:     FAILED (16 warnings)
PMD:          FAILED (10 warnings)
Checkstyle:   FAILED (0 errors, 1 warning)

Correctness:  24/41 tests passed
Memory:       1/1 tests passed
Timing:       35/41 tests passed

Aggregate score: 72.20%
[Compilation: 5%, API: 5%, Spotbugs: 0%, PMD: 0%, Checkstyle: 0%, Correctness: 60%, Memory: 10%, Timing: 20%]

ASSESSMENT DETAILS

The following files were submitted:
----------------------------------
5.9K Jan 22 16:15 BruteCollinearPoints.java
4.9K Jan 22 16:15 FastCollinearPoints.java
4.3K Jan 22 16:15 Point.java


********************************************************************************
*  COMPILING
********************************************************************************


% javac11 Point.java
*-----------------------------------------------------------

% javac11 LineSegment.java
*-----------------------------------------------------------

% javac11 BruteCollinearPoints.java
*-----------------------------------------------------------

% javac11 FastCollinearPoints.java
*-----------------------------------------------------------


================================================================


Checking the APIs of your programs.
*-----------------------------------------------------------
Point:

BruteCollinearPoints:

FastCollinearPoints:

================================================================


********************************************************************************
*  CHECKING STYLE AND COMMON BUG PATTERNS
********************************************************************************


% spotbugs *.class
*-----------------------------------------------------------
M D UC_USELESS_OBJECT UC: The object stored in the variable 'pt' is created and modified, but its value never goes outside of the method 'main()' or produces any side effect.  At Point.java:[line 133]
M D UC_USELESS_OBJECT UC: The object stored in the variable 'pt2' is created and modified, but its value never goes outside of the method 'main()' or produces any side effect.  At Point.java:[line 134]
M D DLS_DEAD_LOCAL_STORE DLS: Assigns a value to the local variable 'slopeResult' but that value is never used.  At Point.java:[line 136]
M D DLS_DEAD_LOCAL_STORE DLS: Assigns a value to the local variable 'comparator' but that value is never used.  At Point.java:[line 137]
M D DLS_DEAD_LOCAL_STORE DLS: Assigns a value to the local variable 'compareResult' but that value is never used.  At Point.java:[line 135]
L D FE_FLOATING_POINT_EQUALITY FE: Tests for exact floating-point equality. Because floating-point calculations may involve rounding, the calculated values may be imprecise.  At Point.java:[line 68]
H D UC_USELESS_VOID_METHOD UC: The void method 'main()' appears to serve no purpose.  At Point.java:[line 139]
L P UPM_UNCALLED_PRIVATE_METHOD UPM: The private method 'pointComparator()' is never called.  At BruteCollinearPoints.java:[line 78]
L D FE_FLOATING_POINT_EQUALITY FE: Tests for exact floating-point equality. Because floating-point calculations may involve rounding, the calculated values may be imprecise.  At BruteCollinearPoints.java:[line 62]
M C WOC_WRITE_ONLY_COLLECTION_LOCAL WOC: Method FastCollinearPoints.segments() creates and initializes a collection but never reads or gains information from it  At FastCollinearPoints.java:[line 82]
L P UPM_UNCALLED_PRIVATE_METHOD UPM: The private method 'slopeComparator()' is never called.  At FastCollinearPoints.java:[line 102]
L D FE_FLOATING_POINT_EQUALITY FE: Tests for exact floating-point equality. Because floating-point calculations may involve rounding, the calculated values may be imprecise.  At FastCollinearPoints.java:[line 70]
L P SIC_INNER_SHOULD_BE_STATIC_ANON SIC: Should the anonymous inner class 'BruteCollinearPoints$1' be refactored into a named static nested class?  At BruteCollinearPoints.java:[line 78]
M P URF_UNREAD_FIELD UrF: The instance (or static) variable 'origin' is never read. Consider removing it from the class.  At FastCollinearPoints.java:[line 47]
L P SIC_INNER_SHOULD_BE_STATIC_ANON SIC: Should the anonymous inner class 'FastCollinearPoints$1' be refactored into a named static nested class?  At FastCollinearPoints.java:[line 94]
L P SIC_INNER_SHOULD_BE_STATIC_ANON SIC: Should the anonymous inner class 'FastCollinearPoints$2' be refactored into a named static nested class?  At FastCollinearPoints.java:[line 102]
Warnings generated: 16


================================================================


% pmd .
*-----------------------------------------------------------
BruteCollinearPoints.java:17: The private instance (or static) variable 'points' can be made 'final'; it is initialized only in the declaration or constructor. [ImmutableField]
BruteCollinearPoints.java:77: Avoid unused private methods, such as 'pointComparator()'. [UnusedPrivateMethod]
FastCollinearPoints.java:17: The private instance (or static) variable 'points' can be made 'final'; it is initialized only in the declaration or constructor. [ImmutableField]
FastCollinearPoints.java:42: The private instance (or static) variable 'origin' can be made 'final'; it is initialized only in the declaration or constructor. [ImmutableField]
FastCollinearPoints.java:43: The private instance (or static) variable 'point' can be made 'final'; it is initialized only in the declaration or constructor. [ImmutableField]
FastCollinearPoints.java:44: The private instance (or static) variable 'slopeToOrigin' can be made 'final'; it is initialized only in the declaration or constructor. [ImmutableField]
FastCollinearPoints.java:101: Avoid unused private methods, such as 'slopeComparator()'. [UnusedPrivateMethod]
Point.java:135: Avoid unused local variables, such as 'compareResult'. [UnusedLocalVariable]
Point.java:136: Avoid unused local variables, such as 'slopeResult'. [UnusedLocalVariable]
Point.java:137: Avoid unused local variables, such as 'comparator'. [UnusedLocalVariable]
PMD ends with 10 warnings.


================================================================


% checkstyle *.java
*-----------------------------------------------------------

% custom checkstyle checks for Point.java
*-----------------------------------------------------------

% custom checkstyle checks for BruteCollinearPoints.java
*-----------------------------------------------------------

% custom checkstyle checks for FastCollinearPoints.java
*-----------------------------------------------------------
[WARN] FastCollinearPoints.java:15:1: Defining a nested class in this program suggests poor design. [Design]
Checkstyle ends with 0 errors and 1 warning.


================================================================


********************************************************************************
*  TESTING CORRECTNESS
********************************************************************************

Testing correctness of Point
*-----------------------------------------------------------
Running 3 total tests.

Test 1: p.slopeTo(q)
  * positive infinite slope, where p and q have coordinates in [0, 500)
  * positive infinite slope, where p and q have coordinates in [0, 32768)
  * negative infinite slope, where p and q have coordinates in [0, 500)
  * negative infinite slope, where p and q have coordinates in [0, 32768)
  * positive zero     slope, where p and q have coordinates in [0, 500)
  * positive zero     slope, where p and q have coordinates in [0, 32768)
  * symmetric for random points p and q with coordinates in [0, 500)
  * symmetric for random points p and q with coordinates in [0, 32768)
  * transitive for random points p, q, and r with coordinates in [0, 500)
  * transitive for random points p, q, and r with coordinates in [0, 32768)
  * slopeTo(), where p and q have coordinates in [0, 500)
  * slopeTo(), where p and q have coordinates in [0, 32768)
  * slopeTo(), where p and q have coordinates in [0, 10)
  * throw a java.lang.NullPointerException if argument is null
==> passed

Test 2: p.compareTo(q)
  * reflexive, where p and q have coordinates in [0, 500)
  * reflexive, where p and q have coordinates in [0, 32768)
  * antisymmetric, where p and q have coordinates in [0, 500)
  * antisymmetric, where p and q have coordinates in [0, 32768)
  * transitive, where p, q, and r have coordinates in [0, 500)
  * transitive, where p, q, and r have coordinates in [0, 32768)
  * sign of compareTo(), where p and q have coordinates in [0, 500)
  * sign of compareTo(), where p and q have coordinates in [0, 32768)
  * sign of compareTo(), where p and q have coordinates in [0, 10)
  * throw java.lang.NullPointerException exception if argument is null
==> passed

Test 3: p.slopeOrder().compare(q, r)
  * reflexive, where p and q have coordinates in [0, 500)
  * reflexive, where p and q have coordinates in [0, 32768)
  * antisymmetric, where p, q, and r have coordinates in [0, 500)
  * antisymmetric, where p, q, and r have coordinates in [0, 32768)
  * transitive, where p, q, r, and s have coordinates in [0, 500)
  * transitive, where p, q, r, and s have coordinates in [0, 32768)
  * sign of compare(), where p, q, and r have coordinates in [0, 500)
  * sign of compare(), where p, q, and r have coordinates in [0, 32768)
  * sign of compare(), where p, q, and r have coordinates in [0, 10)
  * throw java.lang.NullPointerException if either argument is null
==> passed


Total: 3/3 tests passed!


================================================================
********************************************************************************
*  TESTING CORRECTNESS (substituting reference Point and LineSegment)
********************************************************************************

Testing correctness of BruteCollinearPoints
*-----------------------------------------------------------
Running 17 total tests.

The inputs satisfy the following conditions:
  - no duplicate points
  - no 5 (or more) points are collinear
  - all x- and y-coordinates between 0 and 32,767

Test 1: points from a file
  * filename = input8.txt
  * filename = equidistant.txt
  * filename = input40.txt
  * filename = input48.txt
==> passed

Test 2a: points from a file with horizontal line segments
  * filename = horizontal5.txt
  * filename = horizontal25.txt
==> passed

Test 2b: random horizontal line segments
  *  1 random horizontal line segment
  *  5 random horizontal line segments
  * 10 random horizontal line segments
  * 15 random horizontal line segments
==> passed

Test 3a: points from a file with vertical line segments
  * filename = vertical5.txt
  * filename = vertical25.txt
==> passed

Test 3b: random vertical line segments
  *  1 random vertical line segment
  *  5 random vertical line segments
  * 10 random vertical line segments
  * 15 random vertical line segments
==> passed

Test 4a: points from a file with no line segments
  * filename = random23.txt
  * filename = random38.txt
==> passed

Test 4b: random points with no line segments
  *  5 random points
  * 10 random points
  * 20 random points
  * 50 random points
==> passed

Test 5: points from a file with fewer than 4 points
  * filename = input1.txt
  * filename = input2.txt
  * filename = input3.txt
==> passed

Test 6: check for dependence on either compareTo() or compare()
        returning { -1, +1, 0 } instead of { negative integer,
        positive integer, zero }
  * filename = equidistant.txt
  * filename = input40.txt
  * filename = input48.txt
==> passed

Test 7: check for fragile dependence on return value of toString()
  * filename = equidistant.txt
  * filename = input40.txt
  * filename = input48.txt
==> passed

Test 8: random line segments, none vertical or horizontal
  *  1 random line segment
  *  5 random line segments
  * 10 random line segments
  * 15 random line segments
==> passed

Test 9: random line segments
  *  1 random line segment
  *  5 random line segments
  * 10 random line segments
  * 15 random line segments
==> passed

Test 10: check that data type is immutable by testing whether each method
         returns the same value, regardless of any intervening operations
  * input8.txt
    - failed after 6 operations involving BruteCollinearPoints
    - first and last call to segments() returned different arrays

    - sequence of operations was:
          BruteCollinearPoints collinear = new BruteCollinearPoints(points);
          mutate points[] array that was passed to constructor
          collinear.segments()
          collinear.numberOfSegments() -> 2
          collinear.numberOfSegments() -> 2
          collinear.segments()

    - failed on trial 1 of 100

  * equidistant.txt
    - failed after 6 operations involving BruteCollinearPoints
    - first and last call to segments() returned different arrays

    - sequence of operations was:
          BruteCollinearPoints collinear = new BruteCollinearPoints(points);
          mutate points[] array that was passed to constructor
          collinear.segments()
          mutate array returned by last call to segments()
          mutate points[] array that was passed to constructor
          collinear.segments()

    - failed on trial 1 of 100

==> FAILED

Test 11: check that data type does not mutate the constructor argument
  * input8.txt
  * equidistant.txt
==> passed

Test 12: numberOfSegments() is consistent with segments()
  * filename = input8.txt
  * filename = equidistant.txt
  * filename = input40.txt
  * filename = input48.txt
  * filename = horizontal5.txt
  * filename = vertical5.txt
  * filename = random23.txt
==> passed

Test 13: throws an exception if either the constructor argument is null
         or any entry in array is null
  * argument is null
  * Point[] of length 10, number of null entries = 1
    - constructor throws wrong exception
    - constructor throws a java.lang.NullPointerException
    - constructor should throw a java.lang.IllegalArgumentException
     10
      5010 23425
     29906 12761
       175 18182
     29088 10845
     14802 22827
     null
     16547 30891
     27481 20375
     20006 13535
      8890  9799

  * Point[] of length 10, number of null entries = 10
  * Point[] of length 4, number of null entries = 1
    - constructor throws wrong exception
    - constructor throws a java.lang.NullPointerException
    - constructor should throw a java.lang.IllegalArgumentException
     4
      1596  4486
      3680 25081
     null
     28553 25897

  * Point[] of length 3, number of null entries = 1
    - constructor throws wrong exception
    - constructor throws a java.lang.NullPointerException
    - constructor should throw a java.lang.IllegalArgumentException
     3
     26472  6583
      5382   685
     null

  * Point[] of length 2, number of null entries = 1
    - constructor throws wrong exception
    - constructor throws a java.lang.NullPointerException
    - constructor should throw a java.lang.IllegalArgumentException
     2
     17452 23807
     null

  * Point[] of length 1, number of null entries = 1
    - constructor fails to throw an exception
     1
     null

==> FAILED

Test 14: check that the constructor throws an exception if duplicate points
  * 50 points
  * 25 points
  * 5 points
  * 4 points
  * 3 points
  * 2 points
==> passed


Total: 15/17 tests passed!


================================================================
Testing correctness of FastCollinearPoints
*-----------------------------------------------------------
Running 21 total tests.

The inputs satisfy the following conditions:
  - no duplicate points
  - all x- and y-coordinates between 0 and 32,767

Test 1: points from a file
  * filename = input8.txt
    - segments() contains the same segment more than once
    - segment 1: (10000, 0) -> (0, 10000)
    - segment 3: (10000, 0) -> (0, 10000)

    - segments() contains a subsegment of a segment in reference solution
    - student   segment 0: (7000, 3000) -> (0, 10000)
    - reference segment 0: (10000, 0) -> (7000, 3000) -> (3000, 7000) -> (0, 10000)

    - number of entries in student   solution: 7
    - number of entries in reference solution: 2
    - 5 extra entries in student solution, including:
      '(6000, 7000) -> (20000, 21000)'


  * filename = equidistant.txt
    - segments() contains the same segment more than once
    - segment 3: (10000, 0) -> (30000, 0)
    - segment 4: (10000, 0) -> (30000, 0)

    - segments() contains a subsegment of a segment in reference solution
    - student   segment 0: (8000, 2000) -> (0, 10000)
    - reference segment 1: (10000, 0) -> (8000, 2000) -> (2000, 8000) -> (0, 10000)

    - number of entries in student   solution: 15
    - number of entries in reference solution: 4
    - 11 extra entries in student solution, including:
      '(20000, 10000) -> (0, 30000)'


  * filename = input40.txt
    - segments() contains the same segment more than once
    - segment 1: (1000, 17000) -> (29000, 17000)
    - segment 2: (1000, 17000) -> (29000, 17000)

    - segments() contains a subsegment of a segment in reference solution
    - student   segment 0: (13000, 17000) -> (29000, 17000)
    - reference segment 0: (1000, 17000) -> (13000, 17000) -> (17000, 17000) -> (29000, 17000)

    - number of entries in student   solution: 12
    - number of entries in reference solution: 4
    - 9 extra entries in student solution, including:
      '(4000, 29000) -> (28000, 29000)'

    - 1 missing entry in student solution:
      '(1000, 17000) -> (1000, 27000) -> (1000, 28000) -> (1000, 31000)'


  * filename = input48.txt
    - segments() contains the same segment more than once
    - segment 2: (9000, 1000) -> (16000, 22000)
    - segment 3: (9000, 1000) -> (16000, 22000)

    - segments() contains a subsegment of a segment in reference solution
    - student   segment 0: (12000, 10000) -> (16000, 22000)
    - reference segment 3: (9000, 1000) -> (12000, 10000) -> (15000, 19000) -> (16000, 22000)

    - number of entries in student   solution: 16
    - number of entries in reference solution: 6
    - 12 extra entries in student solution, including:
      '(9000, 26000) -> (18000, 26000)'

    - 2 missing entries in student solution, including:
      '(18000, 13000) -> (18000, 23000) -> (18000, 26000) -> (18000, 27000)'


  * filename = input299.txt
    - segments() contains the same segment more than once
    - segment 1: (31000, 500) -> (21900, 9600)
    - segment 4: (31000, 500) -> (21900, 9600)

    - segments() contains a subsegment of a segment in reference solution
    - student   segment 0: (29900, 1600) -> (21900, 9600)
    - reference segment 0: (31000, 500) -> (29900, 1600) -> (23000, 8500) -> (21900, 9600)

    - number of entries in student   solution: 16
    - number of entries in reference solution: 6
    - 12 extra entries in student solution, including:
      '(8500, 17450) -> (17250, 17450)'

    - 2 missing entries in student solution, including:
      '(7300, 10050) -> (7300, 10450) -> (7300, 25700) -> (7300, 31650)'


==> FAILED

Test 2a: points from a file with horizontal line segments
  * filename = horizontal5.txt
    - segments() contains the same segment more than once
    - segment 1: (4750, 4652) -> (16307, 4652)
    - segment 2: (4750, 4652) -> (16307, 4652)

    - segments() contains a subsegment of a segment in reference solution
    - student   segment 0: (5766, 4652) -> (16307, 4652)
    - reference segment 0: (4750, 4652) -> (5766, 4652) -> (9972, 4652) -> (16307, 4652)

    - number of entries in student   solution: 20
    - number of entries in reference solution: 5
    - 15 extra entries in student solution, including:
      '(5067, 14118) -> (7821, 14118)'


  * filename = horizontal25.txt
    - segments() contains the same segment more than once
    - segment 1: (10021, 1256) -> (19615, 1256)
    - segment 2: (10021, 1256) -> (19615, 1256)

    - segments() contains a subsegment of a segment in reference solution
    - student   segment 0: (13505, 1256) -> (19615, 1256)
    - reference segment 0: (10021, 1256) -> (13505, 1256) -> (16419, 1256) -> (19615, 1256)

    - number of entries in student   solution: 100
    - number of entries in reference solution: 25
    - 75 extra entries in student solution, including:
      '(9880, 20913) -> (19666, 20913)'


  * filename = horizontal50.txt
    - segments() contains the same segment more than once
    - segment 1: (2624, 1040) -> (15579, 1040)
    - segment 2: (2624, 1040) -> (15579, 1040)

    - segments() contains a subsegment of a segment in reference solution
    - student   segment 0: (4459, 1040) -> (15579, 1040)
    - reference segment 0: (2624, 1040) -> (4459, 1040) -> (8302, 1040) -> (15579, 1040)

    - number of entries in student   solution: 200
    - number of entries in reference solution: 50
    - 150 extra entries in student solution, including:
      '(5559, 20754) -> (17428, 20754)'


  * filename = horizontal75.txt
    - segments() contains the same segment more than once
    - segment 1: (7903, 1061) -> (20959, 1061)
    - segment 2: (7903, 1061) -> (20959, 1061)

    - segments() contains a subsegment of a segment in reference solution
    - student   segment 0: (8084, 1061) -> (20959, 1061)
    - reference segment 0: (7903, 1061) -> (8084, 1061) -> (17515, 1061) -> (20959, 1061)

    - number of entries in student   solution: 299
    - number of entries in reference solution: 75
    - 224 extra entries in student solution, including:
      '(6545, 20976) -> (14591, 20976)'


  * filename = horizontal100.txt
    - segments() contains the same segment more than once
    - segment 1: (1090, 1279) -> (13975, 1279)
    - segment 2: (1090, 1279) -> (13975, 1279)

    - segments() contains a subsegment of a segment in reference solution
    - student   segment 0: (7354, 1279) -> (13975, 1279)
    - reference segment 0: (1090, 1279) -> (7354, 1279) -> (8690, 1279) -> (13975, 1279)

    - number of entries in student   solution: 400
    - number of entries in reference solution: 100
    - 300 extra entries in student solution, including:
      '(7673, 20698) -> (19642, 20698)'


==> FAILED

Test 2b: random horizontal line segments
  *  1 random horizontal line segment
    - number of entries in student   solution: 0
    - number of entries in reference solution: 1
    - 1 missing entry in student solution:
      '(4180, 17226) -> (7953, 17226) -> (10563, 17226) -> (12567, 17226)'


    - failed on trial 1 of 500
     4
      7953 17226
     12567 17226
      4180 17226
     10563 17226

  *  5 random horizontal line segments
    - segments() contains the same segment more than once
    - segment 1: (1475, 3445) -> (12551, 3445)
    - segment 2: (1475, 3445) -> (12551, 3445)

    - segments() contains a subsegment of a segment in reference solution
    - student   segment 0: (9094, 3445) -> (12551, 3445)
    - reference segment 0: (1475, 3445) -> (9094, 3445) -> (10183, 3445) -> (12551, 3445)

    - number of entries in student   solution: 20
    - number of entries in reference solution: 5
    - 15 extra entries in student solution, including:
      '(12934, 16885) -> (18105, 16885)'


    - failed on trial 1 of 250
     20
     11456 13540
     18321 11615
     10494 14610
      7640 11615
      6652 16885
     11052 11615
     13787 16885
      5759 14610
     10183  3445
     12551  3445
     18105 16885
      1475  3445
      1706 14610
      1432 13540
     11306 11615
      2432 13540
     14458 13540
     17032 14610
     12934 16885
      9094  3445

  * 10 random horizontal line segments
    - segments() contains the same segment more than once
    - segment 1: (8908, 5515) -> (16950, 5515)
    - segment 2: (8908, 5515) -> (16950, 5515)

    - segments() contains a subsegment of a segment in reference solution
    - student   segment 0: (10636, 5515) -> (16950, 5515)
    - reference segment 0: (8908, 5515) -> (10636, 5515) -> (11636, 5515) -> (16950, 5515)

    - number of entries in student   solution: 40
    - number of entries in reference solution: 10
    - 30 extra entries in student solution, including:
      '(7153, 18033) -> (15674, 18033)'


    - failed on trial 1 of 50

  * 15 random horizontal line segments
    - segments() contains the same segment more than once
    - segment 1: (6063, 6104) -> (19924, 6104)
    - segment 2: (6063, 6104) -> (19924, 6104)

    - segments() contains a subsegment of a segment in reference solution
    - student   segment 0: (6264, 6104) -> (19924, 6104)
    - reference segment 0: (6063, 6104) -> (6264, 6104) -> (14894, 6104) -> (19924, 6104)

    - number of entries in student   solution: 60
    - number of entries in reference solution: 15
    - 45 extra entries in student solution, including:
      '(11989, 18901) -> (20143, 18901)'


    - failed on trial 1 of 5

==> FAILED

Test 3a: points from a file with vertical line segments
  * filename = vertical5.txt
    - number of entries in student   solution: 0
    - number of entries in reference solution: 5
    - 5 missing entries in student solution, including:
      '(14407, 10367) -> (14407, 17188) -> (14407, 17831) -> (14407, 19953)'


  * filename = vertical25.txt
    - number of entries in student   solution: 0
    - number of entries in reference solution: 25
    - 25 missing entries in student solution, including:
      '(19953, 10489) -> (19953, 10688) -> (19953, 19299) -> (19953, 20439)'


  * filename = vertical50.txt
    - number of entries in student   solution: 0
    - number of entries in reference solution: 50
    - 50 missing entries in student solution, including:
      '(5991, 15606) -> (5991, 20227) -> (5991, 20340) -> (5991, 20424)'


  * filename = vertical75.txt
    - number of entries in student   solution: 0
    - number of entries in reference solution: 75
    - 75 missing entries in student solution, including:
      '(13780, 16365) -> (13780, 17494) -> (13780, 18253) -> (13780, 18908)'


  * filename = vertical100.txt
    - number of entries in student   solution: 0
    - number of entries in reference solution: 100
    - 100 missing entries in student solution, including:
      '(15135, 15588) -> (15135, 17398) -> (15135, 19476) -> (15135, 20439)'


==> FAILED

Test 3b: random vertical line segments
  *  1 random vertical line segment
    - number of entries in student   solution: 0
    - number of entries in reference solution: 1
    - 1 missing entry in student solution:
      '(11563, 1389) -> (11563, 6235) -> (11563, 14198) -> (11563, 14929)'


    - failed on trial 1 of 500
     4
     11563 14929
     11563  6235
     11563  1389
     11563 14198

  *  5 random vertical line segments
    - number of entries in student   solution: 0
    - number of entries in reference solution: 5
    - 5 missing entries in student solution, including:
      '(11529, 9017) -> (11529, 13776) -> (11529, 19231) -> (11529, 20772)'


    - failed on trial 1 of 250
     20
     11529  9017
     11529 20772
     11529 13776
      1498 13339
      1956 14873
      1956  1376
      1498  5221
      1498 19389
      5746  8959
     13583 14864
      5746 19288
      5746  3602
      1956 14334
     13583 20769
      5746 15062
      1956 20040
      1498 12895
     13583  7181
     13583  3170
     11529 19231

  * 10 random vertical line segments
    - number of entries in student   solution: 0
    - number of entries in reference solution: 10
    - 10 missing entries in student solution, including:
      '(11549, 9402) -> (11549, 10903) -> (11549, 18161) -> (11549, 18941)'


    - failed on trial 1 of 50

  * 15 random vertical line segments
    - number of entries in student   solution: 0
    - number of entries in reference solution: 15
    - 15 missing entries in student solution, including:
      '(19900, 7975) -> (19900, 18626) -> (19900, 19364) -> (19900, 20401)'


    - failed on trial 1 of 5

==> FAILED

Test 4a: points from a file with no line segments
  * filename = random23.txt
  * filename = random38.txt
  * filename = random91.txt
  * filename = random152.txt
==> passed

Test 4b: random points with no line segments
  *  5 random points
  * 10 random points
  * 20 random points
  * 50 random points
==> passed

Test 5a: points from a file with 5 or more on some line segments
  * filename = input9.txt
    - segments() contains the same segment more than once
    - segment 1: (1000, 1000) -> (8000, 8000)
    - segment 2: (1000, 1000) -> (8000, 8000)

    - segments() contains a subsegment of a segment in reference solution
    - student   segment 0: (2000, 2000) -> (8000, 8000)
    - reference segment 0: (1000, 1000) -> (2000, 2000) -> (3000, 3000) -> (4000, 4000) -> (5000, 5000) -> (6000, 6000) -> (7000, 7000) -> (8000, 8000) -> (9000, 9000)

    - number of entries in student   solution: 9
    - number of entries in reference solution: 1
    - 9 extra entries in student solution, including:
      '(2000, 2000) -> (8000, 8000)'

    - 1 missing entry in student solution:
      '(1000, 1000) -> (2000, 2000) -> (3000, 3000) -> (4000, 4000) -> (5000, 5000) -> (6000, 6000) -> (7000, 7000) -> (8000, 8000) -> (9000, 9000)'


  * filename = input10.txt
    - segments() contains the same segment more than once
    - segment 1: (28000, 13500) -> (3000, 26000)
    - segment 3: (28000, 13500) -> (3000, 26000)

    - segments() contains a subsegment of a segment in reference solution
    - student   segment 0: (23000, 16000) -> (3000, 26000)
    - reference segment 0: (28000, 13500) -> (23000, 16000) -> (13000, 21000) -> (3000, 26000)

    - number of entries in student   solution: 9
    - number of entries in reference solution: 2
    - 8 extra entries in student solution, including:
      '(2000, 22000) -> (3500, 28000)'

    - 1 missing entry in student solution:
      '(1000, 18000) -> (2000, 22000) -> (3000, 26000) -> (3500, 28000) -> (4000, 30000)'


  * filename = input20.txt
    - segments() contains the same segment more than once
    - segment 2: (4096, 20992) -> (8128, 20992)
    - segment 3: (4096, 20992) -> (8128, 20992)

    - segments() contains a subsegment of a segment in reference solution
    - student   segment 0: (5120, 20992) -> (8128, 20992)
    - reference segment 0: (4096, 20992) -> (5120, 20992) -> (6144, 20992) -> (7168, 20992) -> (8128, 20992)

    - number of entries in student   solution: 24
    - number of entries in reference solution: 5
    - 21 extra entries in student solution, including:
      '(5120, 29184) -> (8192, 29184)'

    - 2 missing entries in student solution, including:
      '(8192, 25088) -> (8192, 26112) -> (8192, 27136) -> (8192, 28160) -> (8192, 29184)'


  * filename = input50.txt
    - segments() contains the same segment more than once
    - segment 3: (1000, 2000) -> (1000, 23000)
    - segment 6: (1000, 2000) -> (1000, 23000)

    - segments() contains a subsegment of a segment in reference solution
    - student   segment 0: (12000, 10000) -> (16000, 22000)
    - reference segment 4: (9000, 1000) -> (12000, 10000) -> (15000, 19000) -> (16000, 22000)

    - number of entries in student   solution: 30
    - number of entries in reference solution: 7
    - 25 extra entries in student solution, including:
      '(9000, 26000) -> (18000, 26000)'

    - 2 missing entries in student solution, including:
      '(18000, 13000) -> (18000, 23000) -> (18000, 26000) -> (18000, 27000) -> (18000, 30000)'


  * filename = input80.txt
    - segments() contains the same segment more than once
    - segment 4: (13000, 1000) -> (31000, 1000)
    - segment 6: (13000, 1000) -> (31000, 1000)

    - segments() contains a subsegment of a segment in reference solution
    - student   segment 0: (12000, 8000) -> (22000, 28000)
    - reference segment 19: (8000, 0) -> (12000, 8000) -> (14000, 12000) -> (22000, 28000)

    - number of entries in student   solution: 106
    - number of entries in reference solution: 31
    - 83 extra entries in student solution, including:
      '(19000, 29000) -> (28000, 29000)'

    - 8 missing entries in student solution, including:
      '(29000, 14000) -> (29000, 18000) -> (29000, 24000) -> (29000, 31000)'


  * filename = input300.txt
    - segments() contains the same segment more than once
    - segment 1: (31000, 500) -> (21900, 9600)
    - segment 4: (31000, 500) -> (21900, 9600)

    - segments() contains a subsegment of a segment in reference solution
    - student   segment 0: (29900, 1600) -> (21900, 9600)
    - reference segment 0: (31000, 500) -> (29900, 1600) -> (23000, 8500) -> (21900, 9600)

    - number of entries in student   solution: 21
    - number of entries in reference solution: 6
    - 17 extra entries in student solution, including:
      '(8500, 17450) -> (17250, 17450)'

    - 2 missing entries in student solution, including:
      '(7300, 10050) -> (7300, 10450) -> (7300, 17000) -> (7300, 25700) -> (7300, 31650)'


  * filename = inarow.txt
    - segments() contains the same segment more than once
    - segment 3: (0, 0) -> (30000, 0)
    - segment 5: (0, 0) -> (30000, 0)

    - segments() contains a subsegment of a segment in reference solution
    - student   segment 0: (5000, 0) -> (30000, 0)
    - reference segment 1: (0, 0) -> (5000, 0) -> (10000, 0) -> (15000, 0) -> (20000, 0) -> (25000, 0) -> (30000, 0)

    - number of entries in student   solution: 28
    - number of entries in reference solution: 5
    - 25 extra entries in student solution, including:
      '(27000, 7500) -> (18000, 30000)'

    - 2 missing entries in student solution, including:
      '(0, 0) -> (0, 5000) -> (0, 10000) -> (0, 11000) -> (0, 15000) -> (0, 20000) -> (0, 25000) -> (0, 30000)'


==> FAILED

Test 5b: points from a file with 5 or more on some line segments
  * filename = kw1260.txt
    - segments() contains the same segment more than once
    - segment 5: (10681, 193) -> (9837, 685)
    - segment 9: (10681, 193) -> (9837, 685)

    - segments() contains a subsegment of a segment in reference solution
    - student   segment 0: (16507, 473) -> (16666, 1529)
    - reference segment 253: (16454, 121) -> (16507, 473) -> (16560, 825) -> (16613, 1177) -> (16666, 1529)

    - number of entries in student   solution: 1493
    - number of entries in reference solution: 288
    - 1227 extra entries in student solution, including:
      '(13180, 30413) -> (14764, 30467)'

    - 22 missing entries in student solution, including:
      '(15188, 21523) -> (15188, 21611) -> (15188, 21699) -> (15188, 21787) -> (15188, 21875)'


  * filename = rs1423.txt
    - segments() contains the same segment more than once
    - segment 9: (31920, 756) -> (32420, 756)
    - segment 10: (31920, 756) -> (32420, 756)

    - segments() contains a subsegment of a segment in reference solution
    - student   segment 0: (24489, 1325) -> (24087, 3543)
    - reference segment 25: (24690, 216) -> (24489, 1325) -> (24288, 2434) -> (24087, 3543)

    - number of entries in student   solution: 1768
    - number of entries in reference solution: 443
    - 1326 extra entries in student solution, including:
      '(12663, 27972) -> (13443, 28086)'

    - 1 missing entry in student solution:
      '(15294, 17325) -> (15294, 17358) -> (15294, 17391) -> (15294, 17424)'


==> FAILED

Test 6: points from a file with fewer than 4 points
  * filename = input1.txt
  * filename = input2.txt
  * filename = input3.txt
==> passed

Test 7: check for dependence on either compareTo() or compare()
        returning { -1, +1, 0 } instead of { negative integer,
        positive integer, zero }
  * filename = equidistant.txt
    - segments() contains the same segment more than once
    - segment 3: (10000, 0) -> (30000, 0)
    - segment 4: (10000, 0) -> (30000, 0)

    - segments() contains a subsegment of a segment in reference solution
    - student   segment 0: (8000, 2000) -> (0, 10000)
    - reference segment 1: (10000, 0) -> (8000, 2000) -> (2000, 8000) -> (0, 10000)

    - number of entries in student   solution: 15
    - number of entries in reference solution: 4
    - 11 extra entries in student solution, including:
      '(20000, 10000) -> (0, 30000)'


  * filename = input40.txt
    - segments() contains the same segment more than once
    - segment 1: (1000, 17000) -> (29000, 17000)
    - segment 2: (1000, 17000) -> (29000, 17000)

    - segments() contains a subsegment of a segment in reference solution
    - student   segment 0: (13000, 17000) -> (29000, 17000)
    - reference segment 0: (1000, 17000) -> (13000, 17000) -> (17000, 17000) -> (29000, 17000)

    - number of entries in student   solution: 12
    - number of entries in reference solution: 4
    - 9 extra entries in student solution, including:
      '(4000, 29000) -> (28000, 29000)'

    - 1 missing entry in student solution:
      '(1000, 17000) -> (1000, 27000) -> (1000, 28000) -> (1000, 31000)'


  * filename = input48.txt
    - segments() contains the same segment more than once
    - segment 2: (9000, 1000) -> (16000, 22000)
    - segment 3: (9000, 1000) -> (16000, 22000)

    - segments() contains a subsegment of a segment in reference solution
    - student   segment 0: (12000, 10000) -> (16000, 22000)
    - reference segment 3: (9000, 1000) -> (12000, 10000) -> (15000, 19000) -> (16000, 22000)

    - number of entries in student   solution: 16
    - number of entries in reference solution: 6
    - 12 extra entries in student solution, including:
      '(9000, 26000) -> (18000, 26000)'

    - 2 missing entries in student solution, including:
      '(18000, 13000) -> (18000, 23000) -> (18000, 26000) -> (18000, 27000)'


  * filename = input299.txt
    - segments() contains the same segment more than once
    - segment 1: (31000, 500) -> (21900, 9600)
    - segment 4: (31000, 500) -> (21900, 9600)

    - segments() contains a subsegment of a segment in reference solution
    - student   segment 0: (29900, 1600) -> (21900, 9600)
    - reference segment 0: (31000, 500) -> (29900, 1600) -> (23000, 8500) -> (21900, 9600)

    - number of entries in student   solution: 16
    - number of entries in reference solution: 6
    - 12 extra entries in student solution, including:
      '(8500, 17450) -> (17250, 17450)'

    - 2 missing entries in student solution, including:
      '(7300, 10050) -> (7300, 10450) -> (7300, 25700) -> (7300, 31650)'


==> FAILED

Test 8: check for fragile dependence on return value of toString()
  * filename = equidistant.txt
    - segments() contains the same segment more than once
    - segment 3: (10000, 0) -> (30000, 0)
    - segment 4: (10000, 0) -> (30000, 0)

    - segments() contains a subsegment of a segment in reference solution
    - student   segment 0: (8000, 2000) -> (0, 10000)
    - reference segment 1: (10000, 0) -> (8000, 2000) -> (2000, 8000) -> (0, 10000)

    - number of entries in student   solution: 15
    - number of entries in reference solution: 4
    - 11 extra entries in student solution, including:
      '(20000, 10000) -> (0, 30000)'


  * filename = input40.txt
    - segments() contains the same segment more than once
    - segment 1: (1000, 17000) -> (29000, 17000)
    - segment 2: (1000, 17000) -> (29000, 17000)

    - segments() contains a subsegment of a segment in reference solution
    - student   segment 0: (13000, 17000) -> (29000, 17000)
    - reference segment 0: (1000, 17000) -> (13000, 17000) -> (17000, 17000) -> (29000, 17000)

    - number of entries in student   solution: 12
    - number of entries in reference solution: 4
    - 9 extra entries in student solution, including:
      '(4000, 29000) -> (28000, 29000)'

    - 1 missing entry in student solution:
      '(1000, 17000) -> (1000, 27000) -> (1000, 28000) -> (1000, 31000)'


  * filename = input48.txt
    - segments() contains the same segment more than once
    - segment 2: (9000, 1000) -> (16000, 22000)
    - segment 3: (9000, 1000) -> (16000, 22000)

    - segments() contains a subsegment of a segment in reference solution
    - student   segment 0: (12000, 10000) -> (16000, 22000)
    - reference segment 3: (9000, 1000) -> (12000, 10000) -> (15000, 19000) -> (16000, 22000)

    - number of entries in student   solution: 16
    - number of entries in reference solution: 6
    - 12 extra entries in student solution, including:
      '(9000, 26000) -> (18000, 26000)'

    - 2 missing entries in student solution, including:
      '(18000, 13000) -> (18000, 23000) -> (18000, 26000) -> (18000, 27000)'



It is bad style to write code that depends on the particular format of
the output from the toString() method, especially if your reason for
doing so is to circumvent the public API (which intentionally does not
provide access to the x- and y-coordinates).

==> FAILED

Test 9: random line segments, none vertical or horizontal
  *  1 random line segment
    - number of entries in student   solution: 0
    - number of entries in reference solution: 1
    - 1 missing entry in student solution:
      '(5524, 1125) -> (6014, 2433) -> (6504, 3741) -> (7239, 5703)'


    - failed on trial 1 of 500
     4
      7239  5703
      5524  1125
      6014  2433
      6504  3741

  *  5 random line segments
    - segments() contains the same segment more than once
    - segment 4: (4788, 2699) -> (11019, 13821)
    - segment 5: (4788, 2699) -> (11019, 13821)

    - segments() contains a subsegment of a segment in reference solution
    - student   segment 0: (6334, 3305) -> (9722, 13385)
    - reference segment 4: (5850, 1865) -> (6334, 3305) -> (9238, 11945) -> (9722, 13385)

    - number of entries in student   solution: 19
    - number of entries in reference solution: 5
    - 14 extra entries in student solution, including:
      '(15249, 19086) -> (17037, 22042)'


    - failed on trial 1 of 500
     20
      5044 10039
      5997  4857
      2838  3264
      7650  6523
     15744 18708
      9238 11945
      5850  1865
     16461 19566
      9722 13385
      5253  3529
     15249 19086
     17037 22042
     11019 13821
      6262 11474
      2434  6964
      6334  3305
      4788  2699
      8574 10128
     15696 19825
      4348  9219

  * 25 random line segments
    - segments() contains the same segment more than once
    - segment 8: (1670, 3284) -> (14030, 9084)
    - segment 10: (1670, 3284) -> (14030, 9084)

    - segments() contains a subsegment of a segment in reference solution
    - student   segment 0: (2795, 4199) -> (12541, 16981)
    - reference segment 18: (137, 713) -> (2795, 4199) -> (6782, 9428) -> (12541, 16981)

    - number of entries in student   solution: 99
    - number of entries in reference solution: 25
    - 74 extra entries in student solution, including:
      '(5371, 15568) -> (5549, 17512)'


    - failed on trial 1 of 100

  * 50 random line segments
    - segments() contains the same segment more than once
    - segment 9: (5494, 616) -> (9734, 15896)
    - segment 15: (5494, 616) -> (9734, 15896)

    - segments() contains a subsegment of a segment in reference solution
    - student   segment 0: (13070, 3315) -> (14294, 8445)
    - reference segment 45: (12322, 180) -> (13070, 3315) -> (13342, 4455) -> (14294, 8445)

    - number of entries in student   solution: 200
    - number of entries in reference solution: 50
    - 150 extra entries in student solution, including:
      '(8905, 14066) -> (15849, 20968)'


    - failed on trial 1 of 15

  * 100 random line segments
    - segments() contains the same segment more than once
    - segment 46: (517, 493) -> (6974, 5795)
    - segment 53: (517, 493) -> (6974, 5795)

    - segments() contains a subsegment of a segment in reference solution
    - student   segment 0: (14026, 3396) -> (15006, 13096)
    - reference segment 94: (13683, 1) -> (14026, 3396) -> (14418, 7276) -> (15006, 13096)

    - number of entries in student   solution: 400
    - number of entries in reference solution: 100
    - 300 extra entries in student solution, including:
      '(8459, 15753) -> (12023, 16889)'


    - failed on trial 1 of 2

==> FAILED

Test 10: random line segments
  *  1 random line segment
    - number of entries in student   solution: 0
    - number of entries in reference solution: 1
    - 1 missing entry in student solution:
      '(7732, 9872) -> (9532, 11572) -> (9712, 11742) -> (9802, 11827)'


    - failed on trial 1 of 500
     4
      9532 11572
      7732  9872
      9712 11742
      9802 11827

  *  5 random line segments
    - segments() contains the same segment more than once
    - segment 1: (11964, 1016) -> (13389, 6051)
    - segment 2: (11964, 1016) -> (13389, 6051)

    - segments() contains a subsegment of a segment in reference solution
    - student   segment 0: (12054, 1334) -> (13389, 6051)
    - reference segment 2: (11964, 1016) -> (12054, 1334) -> (12984, 4620) -> (13389, 6051)

    - number of entries in student   solution: 14
    - number of entries in reference solution: 5
    - 10 extra entries in student solution, including:
      '(9202, 12687) -> (12994, 12927)'

    - 1 missing entry in student solution:
      '(12079, 849) -> (12079, 1038) -> (12079, 4125) -> (12079, 4314)'


    - failed on trial 1 of 500
     20
      7659 12681
      8350  6099
     12994 12927
      8491 12642
      9202 12687
     12984  4620
     12079  4314
      7944  4649
      8672  7249
      8224  5649
      9718 13841
      8511 13161
      9913 12732
     12054  1334
     12079  1038
     11964  1016
      6523 12041
     12079   849
     12079  4125
     13389  6051

  * 25 random line segments
    - segments() contains the same segment more than once
    - segment 2: (5179, 397) -> (9463, 4749)
    - segment 7: (5179, 397) -> (9463, 4749)

    - segments() contains a subsegment of a segment in reference solution
    - student   segment 0: (5494, 717) -> (9463, 4749)
    - reference segment 14: (5179, 397) -> (5494, 717) -> (6691, 1933) -> (9463, 4749)

    - number of entries in student   solution: 99
    - number of entries in reference solution: 25
    - 74 extra entries in student solution, including:
      '(4143, 14610) -> (6259, 14610)'


    - failed on trial 1 of 100

  * 50 random line segments
    - segments() contains the same segment more than once
    - segment 14: (6952, 2370) -> (8716, 4274)
    - segment 19: (6952, 2370) -> (8716, 4274)

    - segments() contains a subsegment of a segment in reference solution
    - student   segment 0: (4916, 2494) -> (6319, 6093)
    - reference segment 36: (4387, 1137) -> (4916, 2494) -> (6158, 5680) -> (6319, 6093)

    - number of entries in student   solution: 184
    - number of entries in reference solution: 50
    - 138 extra entries in student solution, including:
      '(10868, 14406) -> (13970, 14406)'

    - 4 missing entries in student solution, including:
      '(13976, 9286) -> (13976, 9638) -> (13976, 11354) -> (13976, 11750)'


    - failed on trial 1 of 15

  * 100 random line segments
    - segments() contains the same segment more than once
    - segment 5: (3333, 59) -> (5711, 4931)
    - segment 20: (3333, 59) -> (5711, 4931)

    - segments() contains a subsegment of a segment in reference solution
    - student   segment 0: (3784, 983) -> (5711, 4931)
    - reference segment 69: (3333, 59) -> (3784, 983) -> (4522, 2495) -> (5711, 4931)

    - number of entries in student   solution: 368
    - number of entries in reference solution: 100
    - 276 extra entries in student solution, including:
      '(5735, 14262) -> (8308, 14541)'

    - 8 missing entries in student solution, including:
      '(9167, 11830) -> (9167, 11893) -> (9167, 11921) -> (9167, 12047)'


    - failed on trial 1 of 2

==> FAILED

Test 11: random distinct points in a given range
  * 5 random points in a 10-by-10 grid
    - segments() contains the same segment more than once
    - segment 0: (0, 5) -> (5, 5)
    - segment 1: (0, 5) -> (5, 5)

    - segments() contains a subsegment of a segment in reference solution
    - student   segment 2: (0, 5) -> (2, 5)
    - reference segment 0: (0, 5) -> (1, 5) -> (2, 5) -> (5, 5)

    - number of entries in student   solution: 3
    - number of entries in reference solution: 1
    - 2 extra entries in student solution, including:
      '(0, 5) -> (5, 5)'


    - failed on trial 165 of 500
     5
         1     0
         0     5
         5     5
         2     5
         1     5

  * 10 random points in a 10-by-10 grid
    - segments() contains the same segment more than once
    - segment 1: (0, 4) -> (8, 4)
    - segment 2: (0, 4) -> (8, 4)

    - segments() contains a subsegment of a segment in reference solution
    - student   segment 0: (3, 4) -> (8, 4)
    - reference segment 0: (0, 4) -> (3, 4) -> (7, 4) -> (8, 4)

    - number of entries in student   solution: 4
    - number of entries in reference solution: 1
    - 3 extra entries in student solution, including:
      '(3, 4) -> (8, 4)'


    - failed on trial 15 of 500
     10
         7     3
         2     1
         4     9
         0     6
         3     3
         7     4
         3     4
         8     4
         0     4
         4     0

  * 50 random points in a 10-by-10 grid
    - segments() contains the same segment more than once
    - segment 4: (0, 0) -> (9, 0)
    - segment 9: (0, 0) -> (9, 0)

    - segments() contains a subsegment of a segment in reference solution
    - student   segment 0: (1, 0) -> (9, 0)
    - reference segment 14: (0, 0) -> (1, 0) -> (4, 0) -> (6, 0) -> (9, 0)

    - number of entries in student   solution: 201
    - number of entries in reference solution: 42
    - 168 extra entries in student solution, including:
      '(4, 8) -> (6, 8)'

    - 9 missing entries in student solution, including:
      '(8, 2) -> (8, 3) -> (8, 4) -> (8, 5) -> (8, 7)'


    - failed on trial 1 of 100

  * 90 random points in a 10-by-10 grid
    - segments() contains the same segment more than once
    - segment 8: (0, 0) -> (9, 0)
    - segment 13: (0, 0) -> (9, 0)

    - segments() contains a subsegment of a segment in reference solution
    - student   segment 0: (1, 0) -> (9, 0)
    - reference segment 52: (0, 0) -> (1, 0) -> (2, 0) -> (3, 0) -> (4, 0) -> (5, 0) -> (6, 0) -> (7, 0) -> (8, 0) -> (9, 0)

    - number of entries in student   solution: 676
    - number of entries in reference solution: 124
    - 562 extra entries in student solution, including:
      '(2, 9) -> (9, 9)'

    - 10 missing entries in student solution, including:
      '(9, 0) -> (9, 1) -> (9, 2) -> (9, 3) -> (9, 5) -> (9, 6) -> (9, 7) -> (9, 8) -> (9, 9)'


    - failed on trial 1 of 50

  * 200 random points in a 50-by-50 grid
    - segments() contains the same segment more than once
    - segment 18: (34, 2) -> (49, 2)
    - segment 24: (34, 2) -> (49, 2)

    - segments() contains a subsegment of a segment in reference solution
    - student   segment 0: (31, 24) -> (28, 42)
    - reference segment 2: (35, 0) -> (31, 24) -> (30, 30) -> (28, 42)

    - number of entries in student   solution: 990
    - number of entries in reference solution: 221
    - 798 extra entries in student solution, including:
      '(7, 49) -> (41, 49)'

    - 29 missing entries in student solution, including:
      '(13, 23) -> (13, 32) -> (13, 36) -> (13, 46)'


    - failed on trial 1 of 10

==> FAILED

Test 12: m*n points on an m-by-n grid
  * 3-by-3 grid
  * 4-by-4 grid
    - segments() contains the same segment more than once
    - segment 2: (0, 0) -> (3, 0)
    - segment 3: (0, 0) -> (3, 0)

    - segments() contains a subsegment of a segment in reference solution
    - student   segment 0: (1, 0) -> (3, 0)
    - reference segment 1: (0, 0) -> (1, 0) -> (2, 0) -> (3, 0)

    - number of entries in student   solution: 24
    - number of entries in reference solution: 10
    - 18 extra entries in student solution, including:
      '(1, 3) -> (3, 3)'

    - 4 missing entries in student solution, including:
      '(3, 0) -> (3, 1) -> (3, 2) -> (3, 3)'


  * 5-by-5 grid
    - segments() contains the same segment more than once
    - segment 3: (0, 0) -> (4, 0)
    - segment 6: (0, 0) -> (4, 0)

    - segments() contains a subsegment of a segment in reference solution
    - student   segment 0: (1, 0) -> (4, 0)
    - reference segment 3: (0, 0) -> (1, 0) -> (2, 0) -> (3, 0) -> (4, 0)

    - number of entries in student   solution: 76
    - number of entries in reference solution: 16
    - 65 extra entries in student solution, including:
      '(1, 4) -> (4, 4)'

    - 5 missing entries in student solution, including:
      '(4, 0) -> (4, 1) -> (4, 2) -> (4, 3) -> (4, 4)'


  * 10-by-10 grid
    - segments() contains the same segment more than once
    - segment 9: (0, 0) -> (9, 0)
    - segment 16: (0, 0) -> (9, 0)

    - segments() contains a subsegment of a segment in reference solution
    - student   segment 0: (1, 0) -> (9, 0)
    - reference segment 67: (0, 0) -> (1, 0) -> (2, 0) -> (3, 0) -> (4, 0) -> (5, 0) -> (6, 0) -> (7, 0) -> (8, 0) -> (9, 0)

    - number of entries in student   solution: 856
    - number of entries in reference solution: 154
    - 712 extra entries in student solution, including:
      '(1, 9) -> (9, 9)'

    - 10 missing entries in student solution, including:
      '(9, 0) -> (9, 1) -> (9, 2) -> (9, 3) -> (9, 4) -> (9, 5) -> (9, 6) -> (9, 7) -> (9, 8) -> (9, 9)'


  * 20-by-20 grid
    - segments() contains the same segment more than once
    - segment 25: (0, 0) -> (19, 0)
    - segment 50: (0, 0) -> (19, 0)

    - segments() contains a subsegment of a segment in reference solution
    - student   segment 0: (1, 0) -> (19, 0)
    - reference segment 1203: (0, 0) -> (1, 0) -> (2, 0) -> (3, 0) -> (4, 0) -> (5, 0) -> (6, 0) -> (7, 0) -> (8, 0) -> (9, 0) -> (10, 0) -> (11, 0) -> (12, 0) -> (13, 0) -> (14, 0) -> (15, 0) -> (16, 0) -> (17, 0) -> (18, 0) -> (19, 0)

    - number of entries in student   solution: 12984
    - number of entries in reference solution: 2446
    - 10558 extra entries in student solution, including:
      '(1, 19) -> (19, 19)'

    - 20 missing entries in student solution, including:
      '(19, 0) -> (19, 1) -> (19, 2) -> (19, 3) -> (19, 4) -> (19, 5) -> (19, 6) -> (19, 7) -> (19, 8) -> (19, 9) -> (19, 10) -> (19, 11) -> (19, 12) -> (19, 13) -> (19, 14) -> (19, 15) -> (19, 16) -> (19, 17) -> (19, 18) -> (19, 19)'


  * 5-by-4 grid
    - segments() contains the same segment more than once
    - segment 2: (0, 0) -> (4, 0)
    - segment 4: (0, 0) -> (4, 0)

    - segments() contains a subsegment of a segment in reference solution
    - student   segment 0: (1, 0) -> (4, 0)
    - reference segment 2: (0, 0) -> (1, 0) -> (2, 0) -> (3, 0) -> (4, 0)

    - number of entries in student   solution: 36
    - number of entries in reference solution: 13
    - 28 extra entries in student solution, including:
      '(1, 3) -> (4, 3)'

    - 5 missing entries in student solution, including:
      '(4, 0) -> (4, 1) -> (4, 2) -> (4, 3)'


  * 6-by-4 grid
    - segments() contains the same segment more than once
    - segment 2: (0, 0) -> (5, 0)
    - segment 4: (0, 0) -> (5, 0)

    - segments() contains a subsegment of a segment in reference solution
    - student   segment 0: (1, 0) -> (5, 0)
    - reference segment 3: (0, 0) -> (1, 0) -> (2, 0) -> (3, 0) -> (4, 0) -> (5, 0)

    - number of entries in student   solution: 48
    - number of entries in reference solution: 16
    - 38 extra entries in student solution, including:
      '(1, 3) -> (5, 3)'

    - 6 missing entries in student solution, including:
      '(5, 0) -> (5, 1) -> (5, 2) -> (5, 3)'


  * 10-by-4 grid
    - segments() contains the same segment more than once
    - segment 4: (0, 0) -> (9, 0)
    - segment 7: (0, 0) -> (9, 0)

    - segments() contains a subsegment of a segment in reference solution
    - student   segment 0: (1, 0) -> (9, 0)
    - reference segment 12: (0, 0) -> (1, 0) -> (2, 0) -> (3, 0) -> (4, 0) -> (5, 0) -> (6, 0) -> (7, 0) -> (8, 0) -> (9, 0)

    - number of entries in student   solution: 136
    - number of entries in reference solution: 38
    - 108 extra entries in student solution, including:
      '(1, 3) -> (9, 3)'

    - 10 missing entries in student solution, including:
      '(9, 0) -> (9, 1) -> (9, 2) -> (9, 3)'


  * 15-by-4 grid
    - segments() contains the same segment more than once
    - segment 5: (0, 0) -> (14, 0)
    - segment 10: (0, 0) -> (14, 0)

    - segments() contains a subsegment of a segment in reference solution
    - student   segment 0: (1, 0) -> (14, 0)
    - reference segment 30: (0, 0) -> (1, 0) -> (2, 0) -> (3, 0) -> (4, 0) -> (5, 0) -> (6, 0) -> (7, 0) -> (8, 0) -> (9, 0) -> (10, 0) -> (11, 0) -> (12, 0) -> (13, 0) -> (14, 0)

    - number of entries in student   solution: 300
    - number of entries in reference solution: 79
    - 236 extra entries in student solution, including:
      '(1, 3) -> (14, 3)'

    - 15 missing entries in student solution, including:
      '(14, 0) -> (14, 1) -> (14, 2) -> (14, 3)'


  * 25-by-4 grid
    - segments() contains the same segment more than once
    - segment 9: (0, 0) -> (24, 0)
    - segment 17: (0, 0) -> (24, 0)

    - segments() contains a subsegment of a segment in reference solution
    - student   segment 0: (1, 0) -> (24, 0)
    - reference segment 92: (0, 0) -> (1, 0) -> (2, 0) -> (3, 0) -> (4, 0) -> (5, 0) -> (6, 0) -> (7, 0) -> (8, 0) -> (9, 0) -> (10, 0) -> (11, 0) -> (12, 0) -> (13, 0) -> (14, 0) -> (15, 0) -> (16, 0) -> (17, 0) -> (18, 0) -> (19, 0) -> (20, 0) -> (21, 0) -> (22, 0) -> (23, 0) -> (24, 0)

    - number of entries in student   solution: 836
    - number of entries in reference solution: 213
    - 648 extra entries in student solution, including:
      '(1, 3) -> (24, 3)'

    - 25 missing entries in student solution, including:
      '(24, 0) -> (24, 1) -> (24, 2) -> (24, 3)'


==> FAIL

...

WARNING: the grading output was truncated due to excessive length.
Typically, this is because you have a method that has an unanticipated side effect
(such as printing to standard output or throwing an exception). A large amount of output
can also arise from failing many tests.
